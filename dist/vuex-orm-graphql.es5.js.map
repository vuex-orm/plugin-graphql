{"version":3,"file":"vuex-orm-graphql.es5.js","sources":["../node_modules/graphql/jsutils/invariant.js","../node_modules/graphql/language/source.js","../node_modules/graphql/language/location.js","../node_modules/graphql/error/printError.js","../node_modules/graphql/error/GraphQLError.js","../node_modules/graphql/error/syntaxError.js","../node_modules/graphql/error/locatedError.js","../node_modules/graphql/error/formatError.js","../node_modules/graphql/error/index.js","../node_modules/graphql/language/blockStringValue.js","../node_modules/graphql/language/lexer.js","../node_modules/graphql/language/kinds.js","../node_modules/graphql/language/directiveLocation.js","../node_modules/graphql/language/parser.js","../node_modules/graphql/language/visitor.js","../node_modules/graphql/language/printer.js","../node_modules/lodash.isequal/index.js","../src/support/utils.ts","../src/common/logger.ts","../src/orm/model.ts","../node_modules/fast-json-stable-stringify/index.js","../node_modules/apollo-utilities/src/storeUtils.ts","../node_modules/apollo-utilities/src/directives.ts","../node_modules/apollo-utilities/src/fragments.ts","../node_modules/apollo-utilities/src/util/assign.ts","../node_modules/apollo-utilities/src/getFromAST.ts","../node_modules/fclone/dist/fclone.js","../node_modules/apollo-utilities/src/util/cloneDeep.ts","../node_modules/apollo-utilities/src/transform.ts","../node_modules/apollo-utilities/src/util/environment.ts","../node_modules/apollo-utilities/src/util/errorHandling.ts","../node_modules/apollo-utilities/src/util/isEqual.ts","../node_modules/apollo-utilities/src/util/warnOnce.ts","../node_modules/src/core/networkStatus.ts","../node_modules/zen-observable/lib/Observable.js","../node_modules/zen-observable/index.js","../node_modules/zen-observable-ts/src/zenObservable.ts","../node_modules/apollo-link/src/linkUtils.ts","../node_modules/apollo-link/src/link.ts","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/src/util/Observable.ts","../node_modules/src/errors/ApolloError.ts","../node_modules/src/core/types.ts","../node_modules/src/core/ObservableQuery.ts","../node_modules/apollo-link-dedup/src/dedupLink.ts","../node_modules/src/scheduler/scheduler.ts","../node_modules/src/data/mutations.ts","../node_modules/src/data/queries.ts","../node_modules/src/core/QueryManager.ts","../node_modules/src/data/store.ts","../node_modules/apollo-client/version.js","../node_modules/src/ApolloClient.ts","../node_modules/apollo-cache/src/utils.ts","../node_modules/apollo-cache/src/cache.ts","../node_modules/apollo-cache-inmemory/src/fragmentMatcher.ts","../node_modules/apollo-cache-inmemory/src/objectCache.ts","../node_modules/apollo-cache-inmemory/src/writeToStore.ts","../node_modules/graphql-anywhere/src/graphql.ts","../node_modules/apollo-cache-inmemory/src/readFromStore.ts","../node_modules/apollo-cache-inmemory/src/recordingCache.ts","../node_modules/apollo-cache-inmemory/src/inMemoryCache.ts","../node_modules/apollo-link-http-common/src/index.ts","../node_modules/apollo-link-http/src/httpLink.ts","../src/graphql/transformer.ts","../node_modules/graphql-tag/src/index.js","../src/graphql/apollo.ts","../src/graphql/schema.ts","../src/common/context.ts","../src/graphql/query-builder.ts","../src/orm/store.ts","../src/graphql/name-generator.ts","../src/actions/action.ts","../src/actions/destroy.ts","../src/actions/fetch.ts","../src/actions/mutate.ts","../src/actions/persist.ts","../src/actions/push.ts","../src/actions/query.ts","../src/actions/simple-query.ts","../src/actions/simple-mutation.ts","../src/vuex-orm-graphql.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invariant;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction invariant(condition, message) {\n  /* istanbul ignore else */\n  if (!condition) {\n    throw new Error(message);\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Source = undefined;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nvar Source = exports.Source = function Source(body, name, locationOffset) {\n  _classCallCheck(this, Source);\n\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || { line: 1, column: 1 };\n  !(this.locationOffset.line > 0) ? (0, _invariant2.default)(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;\n  !(this.locationOffset.column > 0) ? (0, _invariant2.default)(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;\n};","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLocation = getLocation;\n\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match = void 0;\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n  return { line: line, column: column };\n}\n\n/**\n * Represents a location in a Source.\n */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printError = printError;\n\nvar _location = require('../language/location');\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\nfunction printError(error) {\n  var printedLocations = [];\n  if (error.nodes) {\n    error.nodes.forEach(function (node) {\n      if (node.loc) {\n        printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));\n      }\n    });\n  } else if (error.source && error.locations) {\n    var source = error.source;\n    error.locations.forEach(function (location) {\n      printedLocations.push(highlightSourceAtLocation(source, location));\n    });\n  }\n  return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\\n\\n') + '\\n';\n}\n\n/**\n * Render a helpful description of the location of the error in the GraphQL\n * Source document.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction highlightSourceAtLocation(source, location) {\n  var line = location.line;\n  var lineOffset = source.locationOffset.line - 1;\n  var columnOffset = getColumnOffset(source, location);\n  var contextLine = line + lineOffset;\n  var contextColumn = location.column + columnOffset;\n  var prevLineNum = (contextLine - 1).toString();\n  var lineNum = contextLine.toString();\n  var nextLineNum = (contextLine + 1).toString();\n  var padLen = nextLineNum.length;\n  var lines = source.body.split(/\\r\\n|[\\n\\r]/g);\n  lines[0] = whitespace(source.locationOffset.column - 1) + lines[0];\n  var outputLines = [source.name + ' (' + contextLine + ':' + contextColumn + ')', line >= 2 && lpad(padLen, prevLineNum) + ': ' + lines[line - 2], lpad(padLen, lineNum) + ': ' + lines[line - 1], whitespace(2 + padLen + contextColumn - 1) + '^', line < lines.length && lpad(padLen, nextLineNum) + ': ' + lines[line]];\n  return outputLines.filter(Boolean).join('\\n');\n}\n\nfunction getColumnOffset(source, location) {\n  return location.line === 1 ? source.locationOffset.column - 1 : 0;\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLError = GraphQLError;\n\nvar _printError = require('./printError');\n\nvar _location = require('../language/location');\n\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined;\n\n  // Compute locations in the source for the given nodes/positions.\n  var _source = source;\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n      return list;\n    }, []);\n  }\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations = void 0;\n  if (positions && source) {\n    var providedSource = source;\n    _locations = positions.map(function (pos) {\n      return (0, _location.getLocation)(providedSource, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));\n      }\n      return list;\n    }, []);\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      value: extensions || originalError && originalError.extensions\n    }\n  });\n\n  // Include (non-enumerable) stack trace.\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: { value: GraphQLError },\n  name: { value: 'GraphQLError' },\n  toString: {\n    value: function toString() {\n      return (0, _printError.printError)(this);\n    }\n  }\n});","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.syntaxError = syntaxError;\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction syntaxError(source, position, description) {\n  return new _GraphQLError.GraphQLError('Syntax Error: ' + description, undefined, source, [position]);\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locatedError = locatedError;\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Given an arbitrary Error, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\nfunction locatedError(originalError, nodes, path) {\n  // Note: this uses a brand-check to support GraphQL errors originating from\n  // other contexts.\n  if (originalError && Array.isArray(originalError.path)) {\n    return originalError;\n  }\n\n  return new _GraphQLError.GraphQLError(originalError && originalError.message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the\n                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * \n                                                                                                                                                                                                                                                                   */\n\nexports.formatError = formatError;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n */\nfunction formatError(error) {\n  !error ? (0, _invariant2.default)(0, 'Received null or undefined error.') : void 0;\n  return _extends({}, error.extensions, {\n    message: error.message || 'An unknown error occurred.',\n    locations: error.locations,\n    path: error.path\n  });\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _GraphQLError = require('./GraphQLError');\n\nObject.defineProperty(exports, 'GraphQLError', {\n  enumerable: true,\n  get: function get() {\n    return _GraphQLError.GraphQLError;\n  }\n});\n\nvar _syntaxError = require('./syntaxError');\n\nObject.defineProperty(exports, 'syntaxError', {\n  enumerable: true,\n  get: function get() {\n    return _syntaxError.syntaxError;\n  }\n});\n\nvar _locatedError = require('./locatedError');\n\nObject.defineProperty(exports, 'locatedError', {\n  enumerable: true,\n  get: function get() {\n    return _locatedError.locatedError;\n  }\n});\n\nvar _printError = require('./printError');\n\nObject.defineProperty(exports, 'printError', {\n  enumerable: true,\n  get: function get() {\n    return _printError.printError;\n  }\n});\n\nvar _formatError = require('./formatError');\n\nObject.defineProperty(exports, 'formatError', {\n  enumerable: true,\n  get: function get() {\n    return _formatError.formatError;\n  }\n});","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = blockStringValue;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * Coffeescript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nfunction blockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n\n  // Remove common indentation from all lines but first.\n  var commonIndent = null;\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n    if (indent < line.length && (commonIndent === null || indent < commonIndent)) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  if (commonIndent) {\n    for (var _i = 1; _i < lines.length; _i++) {\n      lines[_i] = lines[_i].slice(commonIndent);\n    }\n  }\n\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenKind = undefined;\nexports.createLexer = createLexer;\nexports.getTokenDesc = getTokenDesc;\n\nvar _error = require('../error');\n\nvar _blockStringValue = require('./blockStringValue');\n\nvar _blockStringValue2 = _interopRequireDefault(_blockStringValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n  if (token.kind !== EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === COMMENT);\n  }\n  return token;\n}\n\n/**\n * The return type of createLexer.\n */\n\n\n// Each kind of token.\nvar SOF = '<SOF>';\nvar EOF = '<EOF>';\nvar BANG = '!';\nvar DOLLAR = '$';\nvar PAREN_L = '(';\nvar PAREN_R = ')';\nvar SPREAD = '...';\nvar COLON = ':';\nvar EQUALS = '=';\nvar AT = '@';\nvar BRACKET_L = '[';\nvar BRACKET_R = ']';\nvar BRACE_L = '{';\nvar PIPE = '|';\nvar BRACE_R = '}';\nvar NAME = 'Name';\nvar INT = 'Int';\nvar FLOAT = 'Float';\nvar STRING = 'String';\nvar BLOCK_STRING = 'BlockString';\nvar COMMENT = 'Comment';\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = exports.TokenKind = {\n  SOF: SOF,\n  EOF: EOF,\n  BANG: BANG,\n  DOLLAR: DOLLAR,\n  PAREN_L: PAREN_L,\n  PAREN_R: PAREN_R,\n  SPREAD: SPREAD,\n  COLON: COLON,\n  EQUALS: EQUALS,\n  AT: AT,\n  BRACKET_L: BRACKET_L,\n  BRACKET_R: BRACKET_R,\n  BRACE_L: BRACE_L,\n  PIPE: PIPE,\n  BRACE_R: BRACE_R,\n  NAME: NAME,\n  INT: INT,\n  FLOAT: FLOAT,\n  STRING: STRING,\n  BLOCK_STRING: BLOCK_STRING,\n  COMMENT: COMMENT\n};\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? token.kind + ' \"' + value + '\"' : token.kind;\n}\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n\n  var position = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + position - lexer.lineStart;\n\n  if (position >= bodyLength) {\n    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    throw (0, _error.syntaxError)(source, position, 'Cannot contain the invalid character ' + printCharCode(code) + '.');\n  }\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(BANG, position, position + 1, line, col, prev);\n    // #\n    case 35:\n      return readComment(source, position, line, col, prev);\n    // $\n    case 36:\n      return new Tok(DOLLAR, position, position + 1, line, col, prev);\n    // (\n    case 40:\n      return new Tok(PAREN_L, position, position + 1, line, col, prev);\n    // )\n    case 41:\n      return new Tok(PAREN_R, position, position + 1, line, col, prev);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n        return new Tok(SPREAD, position, position + 3, line, col, prev);\n      }\n      break;\n    // :\n    case 58:\n      return new Tok(COLON, position, position + 1, line, col, prev);\n    // =\n    case 61:\n      return new Tok(EQUALS, position, position + 1, line, col, prev);\n    // @\n    case 64:\n      return new Tok(AT, position, position + 1, line, col, prev);\n    // [\n    case 91:\n      return new Tok(BRACKET_L, position, position + 1, line, col, prev);\n    // ]\n    case 93:\n      return new Tok(BRACKET_R, position, position + 1, line, col, prev);\n    // {\n    case 123:\n      return new Tok(BRACE_L, position, position + 1, line, col, prev);\n    // |\n    case 124:\n      return new Tok(PIPE, position, position + 1, line, col, prev);\n    // }\n    case 125:\n      return new Tok(BRACE_R, position, position + 1, line, col, prev);\n    // A-Z _ a-z\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, position, line, col, prev);\n    // - 0-9\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, position, code, line, col, prev);\n    // \"\n    case 34:\n      if (charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {\n        return readBlockString(source, position, line, col, prev);\n      }\n      return readString(source, position, line, col, prev);\n  }\n\n  throw (0, _error.syntaxError)(source, position, unexpectedCharacterMessage(code));\n}\n\n/**\n * Report a message that an unexpected character was encountered.\n */\nfunction unexpectedCharacterMessage(code) {\n  if (code === 39) {\n    // '\n    return \"Unexpected single quote character ('), did you mean to use \" + 'a double quote (\")?';\n  }\n\n  return 'Cannot parse the unexpected character ' + printCharCode(code) + '.';\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position);\n    // tab | space | comma | BOM\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n  return position;\n}\n\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code = void 0;\n  var position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (code !== null && (\n  // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&\n  // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += slice.call(body, chunkStart, position);\n      return new Tok(STRING, start, position + 1, line, col, prev, value);\n    }\n\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    ++position;\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n        case 47:\n          value += '/';\n          break;\n        case 92:\n          value += '\\\\';\n          break;\n        case 98:\n          value += '\\b';\n          break;\n        case 102:\n          value += '\\f';\n          break;\n        case 110:\n          value += '\\n';\n          break;\n        case 114:\n          value += '\\r';\n          break;\n        case 116:\n          value += '\\t';\n          break;\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\nfunction readBlockString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {\n      rawValue += slice.call(body, chunkStart, position);\n      return new Tok(BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockStringValue2.default)(rawValue));\n    }\n\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    // Escape Triple-Quote (\\\"\"\")\n    if (code === 92 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34 && charCodeAt.call(body, position + 3) === 34) {\n      rawValue += slice.call(body, chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var end = position + 1;\n  var code = 0;\n  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++end;\n  }\n  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n// Name\n\nvar NAME = exports.NAME = 'Name';\n\n// Document\n\nvar DOCUMENT = exports.DOCUMENT = 'Document';\nvar OPERATION_DEFINITION = exports.OPERATION_DEFINITION = 'OperationDefinition';\nvar VARIABLE_DEFINITION = exports.VARIABLE_DEFINITION = 'VariableDefinition';\nvar VARIABLE = exports.VARIABLE = 'Variable';\nvar SELECTION_SET = exports.SELECTION_SET = 'SelectionSet';\nvar FIELD = exports.FIELD = 'Field';\nvar ARGUMENT = exports.ARGUMENT = 'Argument';\n\n// Fragments\n\nvar FRAGMENT_SPREAD = exports.FRAGMENT_SPREAD = 'FragmentSpread';\nvar INLINE_FRAGMENT = exports.INLINE_FRAGMENT = 'InlineFragment';\nvar FRAGMENT_DEFINITION = exports.FRAGMENT_DEFINITION = 'FragmentDefinition';\n\n// Values\n\nvar INT = exports.INT = 'IntValue';\nvar FLOAT = exports.FLOAT = 'FloatValue';\nvar STRING = exports.STRING = 'StringValue';\nvar BOOLEAN = exports.BOOLEAN = 'BooleanValue';\nvar NULL = exports.NULL = 'NullValue';\nvar ENUM = exports.ENUM = 'EnumValue';\nvar LIST = exports.LIST = 'ListValue';\nvar OBJECT = exports.OBJECT = 'ObjectValue';\nvar OBJECT_FIELD = exports.OBJECT_FIELD = 'ObjectField';\n\n// Directives\n\nvar DIRECTIVE = exports.DIRECTIVE = 'Directive';\n\n// Types\n\nvar NAMED_TYPE = exports.NAMED_TYPE = 'NamedType';\nvar LIST_TYPE = exports.LIST_TYPE = 'ListType';\nvar NON_NULL_TYPE = exports.NON_NULL_TYPE = 'NonNullType';\n\n// Type System Definitions\n\nvar SCHEMA_DEFINITION = exports.SCHEMA_DEFINITION = 'SchemaDefinition';\nvar OPERATION_TYPE_DEFINITION = exports.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';\n\n// Type Definitions\n\nvar SCALAR_TYPE_DEFINITION = exports.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';\nvar OBJECT_TYPE_DEFINITION = exports.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';\nvar FIELD_DEFINITION = exports.FIELD_DEFINITION = 'FieldDefinition';\nvar INPUT_VALUE_DEFINITION = exports.INPUT_VALUE_DEFINITION = 'InputValueDefinition';\nvar INTERFACE_TYPE_DEFINITION = exports.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';\nvar UNION_TYPE_DEFINITION = exports.UNION_TYPE_DEFINITION = 'UnionTypeDefinition';\nvar ENUM_TYPE_DEFINITION = exports.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';\nvar ENUM_VALUE_DEFINITION = exports.ENUM_VALUE_DEFINITION = 'EnumValueDefinition';\nvar INPUT_OBJECT_TYPE_DEFINITION = exports.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';\n\n// Type Extensions\n\nvar SCALAR_TYPE_EXTENSION = exports.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension';\nvar OBJECT_TYPE_EXTENSION = exports.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension';\nvar INTERFACE_TYPE_EXTENSION = exports.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension';\nvar UNION_TYPE_EXTENSION = exports.UNION_TYPE_EXTENSION = 'UnionTypeExtension';\nvar ENUM_TYPE_EXTENSION = exports.ENUM_TYPE_EXTENSION = 'EnumTypeExtension';\nvar INPUT_OBJECT_TYPE_EXTENSION = exports.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension';\n\n// Directive Definitions\n\nvar DIRECTIVE_DEFINITION = exports.DIRECTIVE_DEFINITION = 'DirectiveDefinition';","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = exports.DirectiveLocation = {\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n};\n\n/**\n * The enum type representing the directive location values.\n */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\nvar _directiveLocation = require('./directiveLocation');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\n/**\n * Configuration options to control parser behavior\n */\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - ExecutableDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n      case 'fragment':\n        return parseExecutableDefinition(lexer);\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        // Note: The schema definition language is an experimental addition.\n        return parseTypeSystemDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseExecutableDefinition(lexer);\n  } else if (peekDescription(lexer)) {\n    // Note: The schema definition language is an experimental addition.\n    return parseTypeSystemDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * ExecutableDefinition :\n *   - OperationDefinition\n *   - FragmentDefinition\n */\nfunction parseExecutableDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: undefined,\n      variableDefinitions: [],\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n    case 'mutation':\n      return 'mutation';\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer) {\n  var start = lexer.token;\n\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer, false),\n    directives: parseDirectives(lexer, false),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments[Const] : ( Argument[?Const]+ )\n */\nfunction parseArguments(lexer, isConst) {\n  var item = isConst ? parseConstArgument : parseArgument;\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument[Const] : Name : Value[?Const]\n */\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseConstArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer, false),\n      loc: loc(lexer, start)\n    };\n  }\n  var typeCondition = void 0;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  // Experimental support for defining variables within fragments changes\n  // the grammar of FragmentDefinition:\n  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n  if (lexer.options.experimentalFragmentVariables) {\n    return {\n      kind: _kinds.FRAGMENT_DEFINITION,\n      name: parseFragmentName(lexer),\n      variableDefinitions: parseVariableDefinitions(lexer),\n      typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n      directives: parseDirectives(lexer, false),\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.STRING:\n    case _lexer.TokenKind.BLOCK_STRING:\n      return parseStringLiteral(lexer);\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nfunction parseStringLiteral(lexer) {\n  var token = lexer.token;\n  lexer.advance();\n  return {\n    kind: _kinds.STRING,\n    value: token.value,\n    block: token.kind === _lexer.TokenKind.BLOCK_STRING,\n    loc: loc(lexer, token)\n  };\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives[Const] : Directive[?Const]+\n */\nfunction parseDirectives(lexer, isConst) {\n  var directives = [];\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer, isConst));\n  }\n  return directives;\n}\n\n/**\n * Directive[Const] : @ Name Arguments[?Const]?\n */\nfunction parseDirective(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer, isConst),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtension\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer) {\n  // Many definitions begin with a description and require a lookahead.\n  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n      case 'extend':\n        return parseTypeExtension(lexer);\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\nfunction peekDescription(lexer) {\n  return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);\n}\n\n/**\n * Description : StringValue\n */\nfunction parseDescription(lexer) {\n  if (peekDescription(lexer)) {\n    return parseStringLiteral(lexer);\n  }\n}\n\n/**\n * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n */\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer, true);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n */\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   Description?\n *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n */\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldsDefinition : { FieldDefinition+ }\n */\nfunction parseFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * FieldDefinition :\n *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n */\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition :\n *   - Description? Name : Type DefaultValue? Directives[Const]?\n */\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = void 0;\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition :\n *   - Description? interface Name Directives[Const]? FieldsDefinition?\n */\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeDefinition :\n *   - Description? union Name Directives[Const]? MemberTypesDefinition?\n */\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseMemberTypesDefinition(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * MemberTypesDefinition : = MemberTypes\n *\n * MemberTypes :\n *   - `|`? NamedType\n *   - MemberTypes | NamedType\n */\nfunction parseMemberTypesDefinition(lexer) {\n  var types = [];\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    // Optional leading pipe\n    skip(lexer, _lexer.TokenKind.PIPE);\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.PIPE));\n  }\n  return types;\n}\n\n/**\n * EnumTypeDefinition :\n *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n */\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumValuesDefinition : { EnumValueDefinition+ }\n */\nfunction parseEnumValuesDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * EnumValueDefinition : Description? EnumValue Directives[Const]?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition :\n *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n */\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputFieldsDefinition : { InputValueDefinition+ }\n */\nfunction parseInputFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * TypeExtension :\n *   - ScalarTypeExtension\n *   - ObjectTypeExtension\n *   - InterfaceTypeExtension\n *   - UnionTypeExtension\n *   - EnumTypeExtension\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeExtension(lexer) {\n  var keywordToken = lexer.lookahead();\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'scalar':\n        return parseScalarTypeExtension(lexer);\n      case 'type':\n        return parseObjectTypeExtension(lexer);\n      case 'interface':\n        return parseInterfaceTypeExtension(lexer);\n      case 'union':\n        return parseUnionTypeExtension(lexer);\n      case 'enum':\n        return parseEnumTypeExtension(lexer);\n      case 'input':\n        return parseInputObjectTypeExtension(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\n/**\n * ScalarTypeExtension :\n *   - extend scalar Name Directives[Const]\n */\nfunction parseScalarTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  if (directives.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.SCALAR_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeExtension :\n *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n *  - extend type Name ImplementsInterfaces? Directives[Const]\n *  - extend type Name ImplementsInterfaces\n */\nfunction parseObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.OBJECT_TYPE_EXTENSION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeExtension :\n *   - extend interface Name Directives[Const]? FieldsDefinition\n *   - extend interface Name Directives[Const]\n */\nfunction parseInterfaceTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.INTERFACE_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeExtension :\n *   - extend union Name Directives[Const]? MemberTypesDefinition\n *   - extend union Name Directives[Const]\n */\nfunction parseUnionTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseMemberTypesDefinition(lexer);\n  if (directives.length === 0 && types.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.UNION_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumTypeExtension :\n *   - extend enum Name Directives[Const]? EnumValuesDefinition\n *   - extend enum Name Directives[Const]\n */\nfunction parseEnumTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  if (directives.length === 0 && values.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.ENUM_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeExtension :\n *   - extend input Name Directives[Const]? InputFieldsDefinition\n *   - extend input Name Directives[Const]\n */\nfunction parseInputObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - `|`? DirectiveLocation\n *   - DirectiveLocations | DirectiveLocation\n */\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n  do {\n    locations.push(parseDirectiveLocation(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return locations;\n}\n\n/*\n * DirectiveLocation :\n *   - ExecutableDirectiveLocation\n *   - TypeSystemDirectiveLocation\n *\n * ExecutableDirectiveLocation : one of\n *   `QUERY`\n *   `MUTATION`\n *   `SUBSCRIPTION`\n *   `FIELD`\n *   `FRAGMENT_DEFINITION`\n *   `FRAGMENT_SPREAD`\n *   `INLINE_FRAGMENT`\n *\n * TypeSystemDirectiveLocation : one of\n *   `SCHEMA`\n *   `SCALAR`\n *   `OBJECT`\n *   `FIELD_DEFINITION`\n *   `ARGUMENT_DEFINITION`\n *   `INTERFACE`\n *   `UNION`\n *   `ENUM`\n *   `ENUM_VALUE`\n *   `INPUT_OBJECT`\n *   `INPUT_FIELD_DEFINITION`\n */\nfunction parseDirectiveLocation(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {\n    return name;\n  }\n  throw unexpected(lexer, start);\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\n\n\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar QueryDocumentKeys = exports.QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name',\n  // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations']\n};\n\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\nvar BREAK = exports.BREAK = {};\n\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\nfunction visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      var result = void 0;\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.print = print;\n\nvar _visitor = require('./visitor');\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n\n  // Document\n\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet;\n    // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n\n\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue;\n    return variable + ': ' + type + wrap(' = ', defaultValue);\n  },\n\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n\n  // Fragments\n\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (\n      // Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      'fragment ' + name + wrap('(', join(variableDefinitions, ', '), ')') + ' ' + ('on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n\n  // Value\n\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return JSON.stringify(value);\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n\n  // Directive\n\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n\n  // Type\n\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n\n  // Type System Definitions\n\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n\n  ScalarTypeDefinition: function ScalarTypeDefinition(_ref22) {\n    var description = _ref22.description,\n        name = _ref22.name,\n        directives = _ref22.directives;\n    return join([description, join(['scalar', name, join(directives, ' ')], ' ')], '\\n');\n  },\n\n  ObjectTypeDefinition: function ObjectTypeDefinition(_ref23) {\n    var description = _ref23.description,\n        name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join([description, join(['type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  FieldDefinition: function FieldDefinition(_ref24) {\n    var description = _ref24.description,\n        name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return join([description, name + wrap('(', join(args, ', '), ')') + ': ' + type + wrap(' ', join(directives, ' '))], '\\n');\n  },\n\n  InputValueDefinition: function InputValueDefinition(_ref25) {\n    var description = _ref25.description,\n        name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([description, join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ')], '\\n');\n  },\n\n  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref26) {\n    var description = _ref26.description,\n        name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join([description, join(['interface', name, join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  UnionTypeDefinition: function UnionTypeDefinition(_ref27) {\n    var description = _ref27.description,\n        name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join([description, join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ')], '\\n');\n  },\n\n  EnumTypeDefinition: function EnumTypeDefinition(_ref28) {\n    var description = _ref28.description,\n        name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join([description, join(['enum', name, join(directives, ' '), block(values)], ' ')], '\\n');\n  },\n\n  EnumValueDefinition: function EnumValueDefinition(_ref29) {\n    var description = _ref29.description,\n        name = _ref29.name,\n        directives = _ref29.directives;\n    return join([description, join([name, join(directives, ' ')], ' ')], '\\n');\n  },\n\n  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref30) {\n    var description = _ref30.description,\n        name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join([description, join(['input', name, join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  ScalarTypeExtension: function ScalarTypeExtension(_ref31) {\n    var name = _ref31.name,\n        directives = _ref31.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n\n  ObjectTypeExtension: function ObjectTypeExtension(_ref32) {\n    var name = _ref32.name,\n        interfaces = _ref32.interfaces,\n        directives = _ref32.directives,\n        fields = _ref32.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ');\n  },\n\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives,\n        fields = _ref33.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  UnionTypeExtension: function UnionTypeExtension(_ref34) {\n    var name = _ref34.name,\n        directives = _ref34.directives,\n        types = _ref34.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n\n  EnumTypeExtension: function EnumTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        values = _ref35.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        fields = _ref36.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  DirectiveDefinition: function DirectiveDefinition(_ref37) {\n    var description = _ref37.description,\n        name = _ref37.name,\n        args = _ref37.arguments,\n        locations = _ref37.locations;\n    return join([description, 'directive @' + name + wrap('(', join(args, ', '), ')') + ' on ' + join(locations, ' | ')], '\\n');\n  }\n};\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? indent('{\\n' + join(array, '\\n')) + '\\n}' : '';\n}\n\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && maybeString.replace(/\\n/g, '\\n  ');\n}\n\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? '\"\"\"' + value.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"' : isDescription ? '\"\"\"\\n' + value.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"' : indent('\"\"\"\\n' + value.replace(/\"\"\"/g, '\\\\\"\"\"')) + '\\n\"\"\"';\n}","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","import { parse } from \"graphql/language/parser\";\nimport { print } from \"graphql/language/printer\";\n\n// @ts-ignore\nimport lodashIsEqual from \"lodash.isequal\";\n\n/**\n * Capitalizes the first letter of the given string.\n *\n * @param {string} input\n * @returns {string}\n */\nexport function upcaseFirstLetter(input: string) {\n  return input.charAt(0).toUpperCase() + input.slice(1);\n}\n\n/**\n * Down cases the first letter of the given string.\n *\n * @param {string} input\n * @returns {string}\n */\nexport function downcaseFirstLetter(input: string) {\n  return input.charAt(0).toLowerCase() + input.slice(1);\n}\n\n/**\n * Takes a string with a graphql query and formats it. Useful for debug output and the tests.\n * @param {string} query\n * @returns {string}\n */\nexport function prettify(query: string): string {\n  return print(parse(query));\n}\n\n/**\n * Tells if a object is just a simple object.\n *\n * @param {any} value - Value to check.\n */\nexport function isPlainObject(value: any): boolean {\n  return (\n    value != null && typeof value === \"object\" && Object.getPrototypeOf(value) === Object.prototype\n  );\n}\n\n/**\n * Creates an object composed of the picked `object` properties.\n * @param {object} object - Object.\n * @param {array} props - Properties to pick.\n */\nexport function pick(object: any, props: Array<string>) {\n  if (!object) {\n    return {};\n  }\n\n  let index = -1;\n  const length = props.length;\n  const result = {};\n\n  while (++index < length) {\n    const prop = props[index];\n    result[prop] = object[prop];\n  }\n\n  return result;\n}\n\nexport function isEqual(a: object, b: object): boolean {\n  // Couldn' find a simpler working implementation yet.\n  return lodashIsEqual(a, b);\n}\n\nexport function clone(input: any): any {\n  return JSON.parse(JSON.stringify(input));\n}\n\nexport function takeWhile(\n  array: Array<any>,\n  predicate: (x: any, idx: number, array: Array<any>) => any\n) {\n  let index = -1;\n\n  while (++index < array.length && predicate(array[index], index, array)) {\n    // just increase index\n  }\n\n  return array.slice(0, index);\n}\n\nexport function matches(source: any) {\n  source = clone(source);\n\n  return (object: any) => isEqual(object, source);\n}\n","import { DocumentNode } from \"graphql\";\nimport { Arguments } from \"../support/interfaces\";\nimport { FetchPolicy } from \"apollo-client\";\nimport { isPlainObject, prettify } from \"../support/utils\";\n\n/**\n * Vuex-ORM-Apollo Debug Logger.\n * Wraps console and only logs if enabled.\n *\n * Also contains some methods to format graphql queries for the output\n */\nexport default class Logger {\n  /**\n   * Tells if any logging should happen\n   * @type {boolean}\n   */\n  private readonly enabled: boolean;\n\n  /**\n   * Fancy Vuex-ORM-Apollo prefix for all log messages.\n   * @type {string[]}\n   */\n  private readonly PREFIX = [\n    \"%c Vuex-ORM: GraphQL Plugin %c\",\n    \"background: #35495e; padding: 1px 0; border-radius: 3px; color: #eee;\",\n    \"background: transparent;\"\n  ];\n\n  /**\n   * @constructor\n   * @param {boolean} enabled Tells if any logging should happen\n   */\n  public constructor(enabled: boolean) {\n    this.enabled = enabled;\n    this.log(\"Logging is enabled.\");\n  }\n\n  /**\n   * Wraps console.group. In TEST env console.log is used instead because console.group doesn't work on CLI.\n   * If available console.groupCollapsed will be used instead.\n   * @param {Array<any>} messages\n   */\n  public group(...messages: Array<any>): void {\n    if (this.enabled) {\n      if (console.groupCollapsed) {\n        console.groupCollapsed(...this.PREFIX, ...messages);\n      } else {\n        console.log(...this.PREFIX, ...messages);\n      }\n    }\n  }\n\n  /**\n   * Wrapper for console.groupEnd. In TEST env nothing happens because console.groupEnd doesn't work on CLI.\n   */\n  public groupEnd(): void {\n    if (this.enabled && console.groupEnd) console.groupEnd();\n  }\n\n  /**\n   * Wrapper for console.log.\n   * @param {Array<any>} messages\n   */\n  public log(...messages: Array<any>): void {\n    if (this.enabled) {\n      console.log(...this.PREFIX, ...messages);\n    }\n  }\n\n  /**\n   * Wrapper for console.warn.\n   * @param {Array<any>} messages\n   */\n  public warn(...messages: Array<any>): void {\n    if (this.enabled) {\n      console.warn(...this.PREFIX, ...messages);\n    }\n  }\n\n  /**\n   * Logs a graphql query in a readable format and with all information like fetch policy and variables.\n   * @param {string | DocumentNode} query\n   * @param {Arguments} variables\n   * @param {FetchPolicy} fetchPolicy\n   */\n  public logQuery(query: string | DocumentNode, variables?: Arguments, fetchPolicy?: FetchPolicy) {\n    if (this.enabled) {\n      try {\n        let prettified = \"\";\n        if (isPlainObject(query) && (query as DocumentNode).loc) {\n          prettified = prettify((query as DocumentNode).loc!.source.body);\n        } else {\n          prettified = prettify(query as string);\n        }\n\n        this.group(\n          \"Sending query:\",\n          prettified\n            .split(\"\\n\")[1]\n            .replace(\"{\", \"\")\n            .trim()\n        );\n        console.log(prettified);\n\n        if (variables) console.log(\"VARIABLES:\", variables);\n        if (fetchPolicy) console.log(\"FETCH POLICY:\", fetchPolicy);\n\n        this.groupEnd();\n      } catch (e) {\n        console.error(\"[Vuex-ORM-Apollo] There is a syntax error in the query!\", e, query);\n      }\n    }\n  }\n}\n","import { Model as ORMModel } from \"@vuex-orm/core\";\nimport { Field } from \"../support/interfaces\";\nimport Context from \"../common/context\";\nimport { Mock, MockOptions } from \"../test-utils\";\nimport { pick, isEqual } from \"../support/utils\";\nconst inflection = require(\"inflection\");\n\n/**\n * Wrapper around a Vuex-ORM model with some useful methods.\n *\n * Also provides a mock system, to define mocking responses for actions.\n */\nexport default class Model {\n  /**\n   * The singular name of a model like `blogPost`\n   * @type {string}\n   */\n  public readonly singularName: string;\n\n  /**\n   * The plural name of a model like `blogPosts`\n   * @type {string}\n   */\n  public readonly pluralName: string;\n\n  /**\n   * The original Vuex-ORM model\n   */\n  public readonly baseModel: ORMModel;\n\n  /**\n   * The fields of the model\n   * @type {Map<string, Field>}\n   */\n  public readonly fields: Map<string, Field> = new Map<string, Field>();\n\n  /**\n   * Container for the mocks.\n   * @type {Object}\n   */\n  private mocks: { [key: string]: Array<Mock> } = {};\n\n  /**\n   * @constructor\n   * @param {Model} baseModel The original Vuex-ORM model\n   */\n  public constructor(baseModel: ORMModel) {\n    this.baseModel = baseModel;\n\n    // Generate name variants\n    this.singularName = inflection.singularize(this.baseModel.entity);\n    this.pluralName = inflection.pluralize(this.baseModel.entity);\n\n    // Cache the fields of the model in this.fields\n    const fields = this.baseModel.fields();\n    Object.keys(fields).forEach((name: string) => {\n      this.fields.set(name, fields[name]);\n    });\n  }\n\n  /**\n   * Tells if a field is a numeric field.\n   *\n   * @param {Field | undefined} field\n   * @returns {boolean}\n   */\n  public static isFieldNumber(field: Field | undefined): boolean {\n    if (!field) return false;\n\n    const context = Context.getInstance();\n    return (\n      field instanceof context.components.Number || field instanceof context.components.Increment\n    );\n  }\n\n  /**\n   * Tells if a field is a attribute (and thus not a relation)\n   * @param {Field} field\n   * @returns {boolean}\n   */\n  public static isFieldAttribute(field: Field): boolean {\n    const context = Context.getInstance();\n\n    return (\n      field instanceof context.components.Increment ||\n      field instanceof context.components.Attr ||\n      field instanceof context.components.String ||\n      field instanceof context.components.Number ||\n      field instanceof context.components.Boolean\n    );\n  }\n\n  /**\n   * Tells if a field which represents a relation is a connection (multiple).\n   * @param {Field} field\n   * @returns {boolean}\n   */\n  public static isConnection(field: Field): boolean {\n    const context = Context.getInstance();\n\n    return !(\n      field instanceof context.components.BelongsTo ||\n      field instanceof context.components.HasOne ||\n      field instanceof context.components.MorphTo ||\n      field instanceof context.components.MorphOne\n    );\n  }\n\n  /**\n   * Adds $isPersisted and other meta fields to the model by overwriting the fields() method.\n   * @todo is this a good way to add fields?\n   * @param {Model} model\n   */\n  public static augment(model: Model) {\n    const originalFieldGenerator = model.baseModel.fields.bind(model.baseModel);\n\n    model.baseModel.fields = () => {\n      const originalFields = originalFieldGenerator();\n\n      originalFields[\"$isPersisted\"] = model.baseModel.boolean(false);\n\n      return originalFields;\n    };\n  }\n\n  /**\n   * Returns all fields which should be included in a graphql query: All attributes which are not included in the\n   * skipFields array or start with $.\n   * @returns {Array<string>} field names which should be queried\n   */\n  public getQueryFields(): Array<string> {\n    const fields: Array<string> = [];\n\n    this.fields.forEach((field: Field, name: string) => {\n      if (Model.isFieldAttribute(field) && !this.skipField(name)) {\n        fields.push(name);\n      }\n    });\n\n    return fields;\n  }\n\n  /**\n   * Tells if a field should be ignored. This is true for fields that start with a `$` or is it is within the skipField\n   * property or is the foreignKey of a belongsTo/hasOne relation.\n   *\n   * @param {string} field\n   * @returns {boolean}\n   */\n  public skipField(field: string) {\n    if (field.startsWith(\"$\")) return true;\n    if (this.baseModel.skipFields && this.baseModel.skipFields.indexOf(field) >= 0) return true;\n\n    const context = Context.getInstance();\n\n    let shouldSkipField: boolean = false;\n\n    this.getRelations().forEach((relation: Field) => {\n      if (\n        (relation instanceof context.components.BelongsTo ||\n          relation instanceof context.components.HasOne) &&\n        relation.foreignKey === field\n      ) {\n        shouldSkipField = true;\n        return false;\n      }\n      return true;\n    });\n\n    return shouldSkipField;\n  }\n\n  /**\n   * @returns {Map<string, Field>} all relations of the model which should be included in a graphql query\n   */\n  public getRelations(): Map<string, Field> {\n    const relations = new Map<string, Field>();\n\n    this.fields.forEach((field: Field, name: string) => {\n      if (!Model.isFieldAttribute(field)) {\n        relations.set(name, field);\n      }\n    });\n\n    return relations;\n  }\n\n  /**\n   * This accepts a field like `subjectType` and checks if this is just randomly named `...Type` or it is part\n   * of a polymorphic relation.\n   * @param {string} name\n   * @returns {boolean}\n   */\n  public isTypeFieldOfPolymorphicRelation(name: string): boolean {\n    const context = Context.getInstance();\n    let found: boolean = false;\n\n    context.models.forEach(model => {\n      if (found) return false;\n\n      model.getRelations().forEach(relation => {\n        if (\n          relation instanceof context.components.MorphMany ||\n          relation instanceof context.components.MorphedByMany ||\n          relation instanceof context.components.MorphOne ||\n          relation instanceof context.components.MorphTo ||\n          relation instanceof context.components.MorphToMany\n        ) {\n          if (\n            relation.type === name &&\n            relation.related &&\n            relation.related.entity === this.baseModel.entity\n          ) {\n            found = true;\n            return false;\n          }\n        }\n\n        return true;\n      });\n\n      return true;\n    });\n\n    return found;\n  }\n\n  /**\n   * Returns a record of this model with the given ID.\n   * @param {number} id\n   * @returns {any}\n   */\n  public getRecordWithId(id: number) {\n    return this.baseModel\n      .query()\n      .withAllRecursive()\n      .where(\"id\", id)\n      .first();\n  }\n\n  /**\n   * Determines if we should eager load (means: add as a field in the graphql query) a related entity. belongsTo or\n   * hasOne related entities are always eager loaded. Others can be added to the `eagerLoad` array of the model.\n   *\n   * @param {string} fieldName Name of the field\n   * @param {Field} field Relation field\n   * @param {Model} relatedModel Related model\n   * @returns {boolean}\n   */\n  public shouldEagerLoadRelation(fieldName: string, field: Field, relatedModel: Model): boolean {\n    const context = Context.getInstance();\n\n    if (\n      field instanceof context.components.HasOne ||\n      field instanceof context.components.BelongsTo ||\n      field instanceof context.components.MorphOne\n    ) {\n      return true;\n    }\n\n    const eagerLoadList: Array<String> = this.baseModel.eagerLoad || [];\n    return (\n      eagerLoadList.find(n => {\n        return n === relatedModel.singularName || n === relatedModel.pluralName || n === fieldName;\n      }) !== undefined\n    );\n  }\n\n  /**\n   * Adds a mock.\n   *\n   * @param {Mock} mock - Mock config.\n   * @returns {boolean}\n   */\n  public $addMock(mock: Mock): boolean {\n    if (this.$findMock(mock.action, mock.options)) return false;\n    if (!this.mocks[mock.action]) this.mocks[mock.action] = [];\n\n    this.mocks[mock.action].push(mock);\n    return true;\n  }\n\n  /**\n   * Finds a mock for the given action and options.\n   *\n   * @param {string} action - Name of the action like 'fetch'.\n   * @param {MockOptions} options - MockOptions like { variables: { id: 42 } }.\n   * @returns {Mock | null} null when no mock was found.\n   */\n  public $findMock(action: string, options: MockOptions | undefined): Mock | null {\n    if (this.mocks[action]) {\n      return (\n        this.mocks[action].find(m => {\n          if (!m.options || !options) return true;\n\n          const relevantOptions = pick(options, Object.keys(m.options));\n          return isEqual(relevantOptions, m.options || {});\n        }) || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Hook to be called by all actions in order to get the mock returnValue.\n   *\n   * @param {string} action - Name of the action like 'fetch'.\n   * @param {MockOptions} options - MockOptions.\n   * @returns {any} null when no mock was found.\n   */\n  public $mockHook(action: string, options: MockOptions): any {\n    let returnValue: null | { [key: string]: any } = null;\n    const mock = this.$findMock(action, options);\n\n    if (mock) {\n      if (mock.returnValue instanceof Function) {\n        returnValue = mock.returnValue();\n      } else {\n        returnValue = mock.returnValue || null;\n      }\n    }\n\n    if (returnValue) {\n      if (returnValue instanceof Array) {\n        returnValue.forEach(r => (r.$isPersisted = true));\n      } else {\n        returnValue.$isPersisted = true;\n      }\n\n      return { [this.pluralName]: returnValue };\n    }\n\n    return null;\n  }\n}\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new Error(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject && (idObject as IdValue | JsonValue).type === 'id';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new Error(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle\r\n// the `skip` and `include` directives within GraphQL.\r\nimport {\r\n  FieldNode,\r\n  OperationDefinitionNode,\r\n  SelectionNode,\r\n  VariableNode,\r\n  BooleanValueNode,\r\n  DirectiveNode,\r\n  DocumentNode,\r\n} from 'graphql';\r\n\r\nimport { argumentsObjectFromField } from './storeUtils';\r\n\r\nexport type DirectiveInfo = {\r\n  [fieldName: string]: { [argName: string]: any };\r\n};\r\n\r\nexport function getDirectiveInfoFromField(\r\n  field: FieldNode,\r\n  variables: Object,\r\n): DirectiveInfo {\r\n  if (field.directives && field.directives.length) {\r\n    const directiveObj: DirectiveInfo = {};\r\n    field.directives.forEach((directive: DirectiveNode) => {\r\n      directiveObj[directive.name.value] = argumentsObjectFromField(\r\n        directive,\r\n        variables,\r\n      );\r\n    });\r\n    return directiveObj;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function shouldInclude(\r\n  selection: SelectionNode,\r\n  variables: { [name: string]: any } = {},\r\n): boolean {\r\n  if (!selection.directives) {\r\n    return true;\r\n  }\r\n\r\n  let res: boolean = true;\r\n  selection.directives.forEach(directive => {\r\n    // TODO should move this validation to GraphQL validation once that's implemented.\r\n    if (directive.name.value !== 'skip' && directive.name.value !== 'include') {\r\n      // Just don't worry about directives we don't understand\r\n      return;\r\n    }\r\n\r\n    //evaluate the \"if\" argument and skip (i.e. return undefined) if it evaluates to true.\r\n    const directiveArguments = directive.arguments || [];\r\n    const directiveName = directive.name.value;\r\n    if (directiveArguments.length !== 1) {\r\n      throw new Error(\r\n        `Incorrect number of arguments for the @${directiveName} directive.`,\r\n      );\r\n    }\r\n\r\n    const ifArgument = directiveArguments[0];\r\n    if (!ifArgument.name || ifArgument.name.value !== 'if') {\r\n      throw new Error(`Invalid argument for the @${directiveName} directive.`);\r\n    }\r\n\r\n    const ifValue = directiveArguments[0].value;\r\n    let evaledValue: boolean = false;\r\n    if (!ifValue || ifValue.kind !== 'BooleanValue') {\r\n      // means it has to be a variable value if this is a valid @skip or @include directive\r\n      if (ifValue.kind !== 'Variable') {\r\n        throw new Error(\r\n          `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\r\n        );\r\n      } else {\r\n        evaledValue = variables[(ifValue as VariableNode).name.value];\r\n        if (evaledValue === undefined) {\r\n          throw new Error(\r\n            `Invalid variable referenced in @${directiveName} directive.`,\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      evaledValue = (ifValue as BooleanValueNode).value;\r\n    }\r\n\r\n    if (directiveName === 'skip') {\r\n      evaledValue = !evaledValue;\r\n    }\r\n\r\n    if (!evaledValue) {\r\n      res = false;\r\n    }\r\n  });\r\n\r\n  return res;\r\n}\r\n\r\nexport function flattenSelections(selection: SelectionNode): SelectionNode[] {\r\n  if (\r\n    !(selection as FieldNode).selectionSet ||\r\n    !((selection as FieldNode).selectionSet.selections.length > 0)\r\n  )\r\n    return [selection];\r\n\r\n  return [selection].concat(\r\n    (selection as FieldNode).selectionSet.selections\r\n      .map(selectionNode =>\r\n        [selectionNode].concat(flattenSelections(selectionNode)),\r\n      )\r\n      .reduce((selections, selected) => selections.concat(selected), []),\r\n  );\r\n}\r\n\r\nexport function getDirectiveNames(doc: DocumentNode) {\r\n  // operation => [names of directives];\r\n  const directiveNames = doc.definitions\r\n    .filter(\r\n      (definition: OperationDefinitionNode) =>\r\n        definition.selectionSet && definition.selectionSet.selections,\r\n    )\r\n    // operation => [[Selection]]\r\n    .map(x => flattenSelections(x as any))\r\n    // [[Selection]] => [Selection]\r\n    .reduce((selections, selected) => selections.concat(selected), [])\r\n    // [Selection] => [Selection with Directives]\r\n    .filter(\r\n      (selection: SelectionNode) =>\r\n        selection.directives && selection.directives.length > 0,\r\n    )\r\n    // [Selection with Directives] => [[Directives]]\r\n    .map((selection: SelectionNode) => selection.directives)\r\n    // [[Directives]] => [Directives]\r\n    .reduce((directives, directive) => directives.concat(directive), [])\r\n    // [Directives] => [Name]\r\n    .map((directive: DirectiveNode) => directive.name.value);\r\n  return directiveNames;\r\n}\r\n\r\nexport function hasDirectives(names: string[], doc: DocumentNode) {\r\n  return getDirectiveNames(doc).some(\r\n    (name: string) => names.indexOf(name) > -1,\r\n  );\r\n}\r\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\r\n\r\n/**\r\n * Returns a query document which adds a single query operation that only\r\n * spreads the target fragment inside of it.\r\n *\r\n * So for example a document of:\r\n *\r\n * ```graphql\r\n * fragment foo on Foo { a b c }\r\n * ```\r\n *\r\n * Turns into:\r\n *\r\n * ```graphql\r\n * { ...foo }\r\n *\r\n * fragment foo on Foo { a b c }\r\n * ```\r\n *\r\n * The target fragment will either be the only fragment in the document, or a\r\n * fragment specified by the provided `fragmentName`. If there is more then one\r\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\r\n */\r\nexport function getFragmentQueryDocument(\r\n  document: DocumentNode,\r\n  fragmentName?: string,\r\n): DocumentNode {\r\n  let actualFragmentName = fragmentName;\r\n\r\n  // Build an array of all our fragment definitions that will be used for\r\n  // validations. We also do some validations on the other definitions in the\r\n  // document while building this list.\r\n  const fragments: Array<FragmentDefinitionNode> = [];\r\n  document.definitions.forEach(definition => {\r\n    // Throw an error if we encounter an operation definition because we will\r\n    // define our own operation definition later on.\r\n    if (definition.kind === 'OperationDefinition') {\r\n      throw new Error(\r\n        `Found a ${definition.operation} operation${\r\n          definition.name ? ` named '${definition.name.value}'` : ''\r\n        }. ` +\r\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\r\n      );\r\n    }\r\n    // Add our definition to the fragments array if it is a fragment\r\n    // definition.\r\n    if (definition.kind === 'FragmentDefinition') {\r\n      fragments.push(definition);\r\n    }\r\n  });\r\n\r\n  // If the user did not give us a fragment name then let us try to get a\r\n  // name from a single fragment in the definition.\r\n  if (typeof actualFragmentName === 'undefined') {\r\n    if (fragments.length !== 1) {\r\n      throw new Error(\r\n        `Found ${\r\n          fragments.length\r\n        } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\r\n      );\r\n    }\r\n    actualFragmentName = fragments[0].name.value;\r\n  }\r\n\r\n  // Generate a query document with an operation that simply spreads the\r\n  // fragment inside of it.\r\n  const query: DocumentNode = {\r\n    ...document,\r\n    definitions: [\r\n      {\r\n        kind: 'OperationDefinition',\r\n        operation: 'query',\r\n        selectionSet: {\r\n          kind: 'SelectionSet',\r\n          selections: [\r\n            {\r\n              kind: 'FragmentSpread',\r\n              name: {\r\n                kind: 'Name',\r\n                value: actualFragmentName,\r\n              },\r\n            },\r\n          ],\r\n        },\r\n      },\r\n      ...document.definitions,\r\n    ],\r\n  };\r\n\r\n  return query;\r\n}\r\n","/**\r\n * Adds the properties of one or more source objects to a target object. Works exactly like\r\n * `Object.assign`, but as a utility to maintain support for IE 11.\r\n *\r\n * @see https://github.com/apollostack/apollo-client/pull/1009\r\n */\r\nexport function assign<A, B>(a: A, b: B): A & B;\r\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\r\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\r\nexport function assign<A, B, C, D, E>(\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n  e: E,\r\n): A & B & C & D & E;\r\nexport function assign(target: any, ...sources: Array<any>): any;\r\nexport function assign(\r\n  target: { [key: string]: any },\r\n  ...sources: Array<{ [key: string]: any }>\r\n): { [key: string]: any } {\r\n  sources.forEach(source => {\r\n    if (typeof source === 'undefined' || source === null) {\r\n      return;\r\n    }\r\n    Object.keys(source).forEach(key => {\r\n      target[key] = source[key];\r\n    });\r\n  });\r\n  return target;\r\n}\r\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  if (!mutationDef) {\n    throw new Error('Must contain a mutation definition.');\n  }\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new Error(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  if (operations.length > 1) {\n    throw new Error(\n      `Ambiguous GraphQL document: contains ${operations.length} operations`,\n    );\n  }\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  if (!def) {\n    throw new Error(`GraphQL document is missing an operation`);\n  }\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  if (!queryDef || queryDef.operation !== 'query') {\n    throw new Error('Must contain a query definition.');\n  }\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  if (doc.definitions.length > 1) {\n    throw new Error('Fragment must have exactly one definition.');\n  }\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  if (fragmentDef.kind !== 'FragmentDefinition') {\n    throw new Error('Must be a fragment definition.');\n  }\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new Error(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define('fclone', [], factory);\n    } else if (typeof module === 'object' && module.exports) {\n\t\t\t  //node\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.fclone = factory();\n    }\n}(this, function () {\n  'use strict';\n\n// see if it looks and smells like an iterable object, and do accept length === 0\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) return true;\n\n  var len = item && item.length;\n  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';\n}\n\nfunction fclone(obj, refs) {\n  if (!obj || \"object\" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;\n\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\n    return new Buffer(obj);\n  }\n\n  // typed array Int32Array etc.\n  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\\d]+Array/.test(Object.prototype.toString.call(obj))) {\n    return obj.subarray(0);\n  }\n\n  if (!refs) {\n    refs = [];\n  }\n\n  if (isArrayLike(obj)) {\n    refs[refs.length] = obj;\n    var _l = obj.length;\n    var i = -1;\n    var _copy = [];\n\n    while (_l > ++i) {\n      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);\n    }\n\n    refs.length && refs.length--;\n    return _copy;\n  }\n\n  refs[refs.length] = obj;\n  var copy = {};\n\n  if (obj instanceof Error) {\n    copy.name = obj.name;\n    copy.message = obj.message;\n    copy.stack = obj.stack;\n  }\n\n  var keys = Object.keys(obj);\n  var l = keys.length;\n\n  while (l--) {\n    var k = keys[l];\n    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);\n  }\n\n  refs.length && refs.length--;\n  return copy;\n}\n\nfclone.default = fclone;\n  return fclone\n}));","import fclone from 'fclone';\r\n\r\n/**\r\n * Deeply clones a value to create a new instance.\r\n */\r\nexport function cloneDeep<T>(value: T): T {\r\n  return fclone(value);\r\n}\r\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  DefinitionNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nimport { cloneDeep } from './util/cloneDeep';\n\nimport {\n  checkDocument,\n  getOperationDefinitionOrDie,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n} from './getFromAST';\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isNotEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): Boolean {\n  // keep selections that are still valid\n  return (\n    op.selectionSet.selections.filter(\n      selectionSet =>\n        // anything that doesn't match the compound filter is okay\n        !// not an empty array\n        (\n          selectionSet &&\n          // look into fragments to verify they should stay\n          selectionSet.kind === 'FragmentSpread' &&\n          // see if the fragment in the map is valid (recursively)\n          !isNotEmpty(fragments[selectionSet.name.value], fragments)\n        ),\n    ).length > 0\n  );\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode): Boolean {\n    return directives.some(\n      (dir: RemoveDirectiveConfig | GetDirectiveConfig) => {\n        if (dir.name && dir.name === directive.name.value) return true;\n        if (dir.test && dir.test(directive)) return true;\n        return false;\n      },\n    );\n  };\n}\n\nfunction addTypenameToSelectionSet(\n  selectionSet: SelectionSetNode,\n  isRoot = false,\n) {\n  if (selectionSet.selections) {\n    if (!isRoot) {\n      const alreadyHasThisField = selectionSet.selections.some(selection => {\n        return (\n          selection.kind === 'Field' &&\n          (selection as FieldNode).name.value === '__typename'\n        );\n      });\n\n      if (!alreadyHasThisField) {\n        selectionSet.selections.push(TYPENAME_FIELD);\n      }\n    }\n\n    selectionSet.selections.forEach(selection => {\n      // Must not add __typename if we're inside an introspection query\n      if (selection.kind === 'Field') {\n        if (\n          selection.name.value.lastIndexOf('__', 0) !== 0 &&\n          selection.selectionSet\n        ) {\n          addTypenameToSelectionSet(selection.selectionSet);\n        }\n      } else if (selection.kind === 'InlineFragment') {\n        if (selection.selectionSet) {\n          addTypenameToSelectionSet(selection.selectionSet);\n        }\n      }\n    });\n  }\n}\n\nexport type RemoveDirectiveConfig = {\n  name?: string;\n  test?: (directive: DirectiveNode) => boolean;\n  remove?: boolean;\n};\n\nfunction removeDirectivesFromSelectionSet(\n  directives: RemoveDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n): SelectionSetNode {\n  if (!selectionSet.selections) return selectionSet;\n  // if any of the directives are set to remove this selectionSet, remove it\n  const agressiveRemove = directives.some(\n    (dir: RemoveDirectiveConfig) => dir.remove,\n  );\n\n  selectionSet.selections = selectionSet.selections\n    .map(selection => {\n      if (\n        selection.kind !== 'Field' ||\n        !(selection as FieldNode) ||\n        !selection.directives\n      )\n        return selection;\n      const directiveMatcher = getDirectiveMatcher(directives);\n      let remove: boolean;\n      selection.directives = selection.directives.filter(directive => {\n        const shouldKeep = !directiveMatcher(directive);\n\n        if (!remove && !shouldKeep && agressiveRemove) remove = true;\n\n        return shouldKeep;\n      });\n\n      return remove ? null : selection;\n    })\n    .filter(x => !!x);\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n      selection.selectionSet\n    ) {\n      removeDirectivesFromSelectionSet(directives, selection.selectionSet);\n    }\n  });\n\n  return selectionSet;\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const docClone = cloneDeep(doc);\n\n  docClone.definitions.forEach((definition: DefinitionNode) => {\n    removeDirectivesFromSelectionSet(\n      directives,\n      (definition as OperationDefinitionNode).selectionSet,\n    );\n  });\n  const operation = getOperationDefinitionOrDie(docClone);\n  const fragments = createFragmentMap(getFragmentDefinitions(docClone));\n  return isNotEmpty(operation, fragments) ? docClone : null;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode) {\n  checkDocument(doc);\n  const docClone = cloneDeep(doc);\n\n  docClone.definitions.forEach((definition: DefinitionNode) => {\n    const isRoot = definition.kind === 'OperationDefinition';\n    addTypenameToSelectionSet(\n      (definition as OperationDefinitionNode).selectionSet,\n      isRoot,\n    );\n  });\n  return docClone;\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        console.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  checkDocument(doc);\n  return removeDirectivesFromDocument([connectionRemoveConfig], doc);\n}\n\nexport type GetDirectiveConfig = {\n  name?: string;\n  test?: (directive: DirectiveNode) => boolean;\n};\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  if (!(selectionSet && selectionSet.selections)) {\n    return false;\n  }\n  const matchedSelections = selectionSet.selections.filter(selection => {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n  return matchedSelections.length > 0;\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (selection.kind !== 'Field' || !(selection as FieldNode)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const matchedDirectives = selection.directives.filter(directiveMatcher);\n  return (\n    matchedDirectives.length > 0 ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getDirectivesFromSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n) {\n  selectionSet.selections = selectionSet.selections\n    .filter(selection => {\n      return hasDirectivesInSelection(directives, selection, true);\n    })\n    .map(selection => {\n      if (hasDirectivesInSelection(directives, selection, false)) {\n        return selection;\n      }\n      if (\n        (selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n        selection.selectionSet\n      ) {\n        selection.selectionSet = getDirectivesFromSelectionSet(\n          directives,\n          selection.selectionSet,\n        );\n      }\n      return selection;\n    });\n  return selectionSet;\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n  includeAllFragments = false,\n): DocumentNode | null {\n  checkDocument(doc);\n  const docClone = cloneDeep(doc);\n  docClone.definitions = docClone.definitions.map(definition => {\n    if (\n      (definition.kind === 'OperationDefinition' ||\n        (definition.kind === 'FragmentDefinition' && !includeAllFragments)) &&\n      definition.selectionSet\n    ) {\n      definition.selectionSet = getDirectivesFromSelectionSet(\n        directives,\n        definition.selectionSet,\n      );\n    }\n    return definition;\n  });\n\n  const operation = getOperationDefinitionOrDie(docClone);\n  const fragments = createFragmentMap(getFragmentDefinitions(docClone));\n  return isNotEmpty(operation, fragments) ? docClone : null;\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","/**\n * Performs a deep equality check on two JavaScript values.\n */\nexport function isEqual(a: any, b: any): boolean {\n  // If the two values are strictly equal, we are good.\n  if (a === b) {\n    return true;\n  }\n  // Dates are equivalent if their time values are equal.\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  // If a and b are both objects, we will compare their properties. This will compare arrays as\n  // well.\n  if (\n    a != null &&\n    typeof a === 'object' &&\n    b != null &&\n    typeof b === 'object'\n  ) {\n    // Compare all of the keys in `a`. If one of the keys has a different value, or that key does\n    // not exist in `b` return false immediately.\n    for (const key in a) {\n      if (Object.prototype.hasOwnProperty.call(a, key)) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\n          return false;\n        }\n        if (!isEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    // Look through all the keys in `b`. If `b` has a key that `a` does not, return false.\n    for (const key in b) {\n      if (!Object.prototype.hasOwnProperty.call(a, key)) {\n        return false;\n      }\n    }\n    // If we made it this far the objects are equal!\n    return true;\n  }\n  // Otherwise the values are not equal.\n  return false;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (isProduction()) {\n    return;\n  }\n  if (!haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    switch (type) {\n      case 'error':\n        console.error(msg);\n        break;\n      default:\n        console.warn(msg);\n    }\n  }\n}\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/networkStatus.ts"},"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[getSymbol('species')];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (sources.length === 0) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources.shift()));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: getSymbol('observable'),\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, getSymbol('observable'));\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, getSymbol('iterator'));\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: getSymbol('species'),\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: getSymbol('observable'),\n      hostReportError: hostReportError\n    },\n    configurabe: true\n  });\n}","module.exports = require('./lib/Observable.js').Observable;\n","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","import { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new Error(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          console.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX we're assuming here that variables will be serialized in the same order.\n  // that might not always be true\n  return `${print(operation.query)}|${JSON.stringify(operation.variables)}|${\n    operation.operationName\n  }`;\n}\n","import Observable from 'zen-observable-ts';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nconst passthrough = (op, forward) => (forward ? forward(op) : Observable.of());\n\nconst toLink = (handler: RequestHandler | ApolloLink) =>\n  typeof handler === 'function' ? new ApolloLink(handler) : handler;\n\nexport const empty = (): ApolloLink =>\n  new ApolloLink((op, forward) => Observable.of());\n\nexport const from = (links: ApolloLink[]): ApolloLink => {\n  if (links.length === 0) return empty();\n\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n};\n\nexport const split = (\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n): ApolloLink => {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right);\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n};\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    console.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n  ): ApolloLink {\n    return this.concat(split(test, left, right));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new Error('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/util/Observable.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/errors/ApolloError.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/types.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/ObservableQuery.ts"},"import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  Observable,\n} from 'apollo-link';\n\n/*\n * Expects context to contain the forceFetch field if no dedup\n */\nexport class DedupLink extends ApolloLink {\n  private inFlightRequestObservables: Map<\n    string,\n    Observable<FetchResult>\n  > = new Map();\n  private subscribers: Map<string, any> = new Map();\n\n  public request(\n    operation: Operation,\n    forward: NextLink,\n  ): Observable<FetchResult> {\n    // sometimes we might not want to deduplicate a request, for example when we want to force fetch it.\n    if (operation.getContext().forceFetch) {\n      return forward(operation);\n    }\n\n    const key = operation.toKey();\n\n    const cleanup = operationKey => {\n      this.inFlightRequestObservables.delete(operationKey);\n      const prev = this.subscribers.get(operationKey);\n      return prev;\n    };\n\n    if (!this.inFlightRequestObservables.get(key)) {\n      // this is a new request, i.e. we haven't deduplicated it yet\n      // call the next link\n      const singleObserver = forward(operation);\n      let subscription;\n\n      const sharedObserver = new Observable(observer => {\n        // this will still be called by each subscriber regardless of\n        // deduplication status\n        let prev = this.subscribers.get(key);\n        if (!prev) prev = { next: [], error: [], complete: [] };\n\n        this.subscribers.set(key, {\n          next: prev.next.concat([observer.next.bind(observer)]),\n          error: prev.error.concat([observer.error.bind(observer)]),\n          complete: prev.complete.concat([observer.complete.bind(observer)]),\n        });\n\n        if (!subscription) {\n          subscription = singleObserver.subscribe({\n            next: result => {\n              const previous = cleanup(key);\n              this.subscribers.delete(key);\n              if (previous) {\n                previous.next.forEach(next => next(result));\n                previous.complete.forEach(complete => complete());\n              }\n            },\n            error: error => {\n              const previous = cleanup(key);\n              this.subscribers.delete(key);\n              if (previous) previous.error.forEach(err => err(error));\n            },\n          });\n        }\n\n        return () => {\n          if (subscription) subscription.unsubscribe();\n          this.inFlightRequestObservables.delete(key);\n        };\n      });\n\n      this.inFlightRequestObservables.set(key, sharedObserver);\n    }\n\n    // return shared Observable\n    return this.inFlightRequestObservables.get(key);\n  }\n}\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/scheduler/scheduler.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/mutations.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/queries.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/QueryManager.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/store.ts"},"exports.version = \"2.4.2\"",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/ApolloClient.ts"},"import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n    };\n\n    // Recurse\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    if (nestedSelSet) {\n      field.selectionSet = nestedSelSet;\n    }\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DocumentNode } from 'graphql';\nimport { getFragmentQueryDocument } from 'apollo-utilities';\n\nimport { DataProxy, Cache } from './types';\nimport { justTypenameQuery, queryFromPojo, fragmentFromPojo } from './utils';\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  // required to implement\n  // core API\n  public abstract read<T, TVariables = any>(\n    query: Cache.ReadOptions<TVariables>,\n  ): T | null;\n  public abstract write<TResult = any, TVariables = any>(\n    write: Cache.WriteOptions<TResult, TVariables>,\n  ): void;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch(watch: Cache.WatchOptions): () => void;\n  public abstract evict<TVariables = any>(\n    query: Cache.EvictOptions<TVariables>,\n  ): Cache.EvictionResult;\n  public abstract reset(): Promise<void>;\n\n  // intializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized,\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // optimistic API\n  public abstract removeOptimistic(id: string): void;\n\n  // transactional API\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n  ): void;\n  public abstract recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    id: string,\n  ): void;\n\n  // optional API\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n  // experimental\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType | null {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: Cache.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: options.query,\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: Cache.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      variables: options.variables,\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n    });\n  }\n\n  public writeData<TData = any>({\n    id,\n    data,\n  }: Cache.WriteDataOptions<TData>): void {\n    if (typeof id !== 'undefined') {\n      let typenameResult = null;\n      // Since we can't use fragments without having a typename in the store,\n      // we need to make sure we have one.\n      // To avoid overwriting an existing typename, we need to read it out first\n      // and generate a fake one if none exists.\n      try {\n        typenameResult = this.read({\n          rootId: id,\n          optimistic: false,\n          query: justTypenameQuery,\n        });\n      } catch (e) {\n        // Do nothing, since an error just means no typename exists\n      }\n\n      // tslint:disable-next-line\n      const __typename =\n        (typenameResult && typenameResult.__typename) || '__ClientData';\n\n      // Add a type here to satisfy the inmemory cache\n      const dataToWrite = Object.assign({ __typename }, data);\n\n      this.writeFragment({\n        id,\n        fragment: fragmentFromPojo(dataToWrite, __typename),\n        data: dataToWrite,\n      });\n    } else {\n      this.writeQuery({ query: queryFromPojo(data), data });\n    }\n  }\n}\n","import { isTest, warnOnceInDevelopment, IdValue } from 'apollo-utilities';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean {\n    const obj = context.store.get(idValue.id);\n\n    if (!obj && idValue.id === 'ROOT_QUERY') {\n      return true;\n    }\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        console.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        console.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n\n        /* istanbul ignore if */\n        if (!isTest()) {\n          // When running tests, we want to print the warning every time\n          haveWarned = true;\n        }\n      }\n\n      context.returnPartialData = true;\n      return true;\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    // XXX here we reach an issue - we don't know if this fragment should match or not. It's either:\n    // 1. A fragment on a non-matching concrete type or interface or union\n    // 2. A fragment on a matching interface or union\n    // If it's 1, we don't want to return anything, if it's 2 we want to match. We can't tell the\n    // difference, so we warn the user, but still try to match it (backcompat).\n    warnOnceInDevelopment(\n      'You are using the simple (heuristic) fragment matcher, but your ' +\n        'queries contain union or interface types. Apollo Client will not be ' +\n        'able to accurately map fragments. To make this error go away, use ' +\n        'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n        'https://www.apollographql.com/docs/react/recipes/fragment-matching.html',\n      'error',\n    );\n\n    context.returnPartialData = true;\n    return true;\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    if (!this.isReady) {\n      // this should basically never happen in proper use.\n      throw new Error(\n        'FragmentMatcher.match() was called before FragmentMatcher.init()',\n      );\n    }\n\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\n        `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n          obj,\n        )}`,\n      );\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {}\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n  public get(dataId: string): StoreObject {\n    return this.data[dataId];\n  }\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n  public delete(dataId: string): void {\n    this.data[dataId] = undefined;\n  }\n  public clear(): void {\n    this.data = Object.create(null);\n  }\n  public replace(newData: NormalizedCacheObject): void {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { FragmentMatcher } from 'graphql-anywhere';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  getQueryDefinition,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { defaultNormalizedCacheFactory, ObjectCache } from './objectCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  NormalizedCacheFactory,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${print(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\n/**\n * Writes the result of a query to the store.\n *\n * @param result The result object returned for the query document.\n *\n * @param query The query document whose result we are writing to the store.\n *\n * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n *\n * @param variables A map from the name of a variable to its value. These variables can be\n * referenced by the query document.\n *\n * @param dataIdFromObject A function that returns an object identifier given a particular result\n * object. See the store documentation for details and an example of this function.\n *\n * @param fragmentMap A map from the name of a fragment to its fragment definition. These fragments\n * can be referenced within the query document.\n *\n * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n */\nexport function writeQueryToStore({\n  result,\n  query,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMap = {} as FragmentMap,\n  fragmentMatcherFunction,\n}: {\n  result: Object;\n  query: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  const queryDefinition: OperationDefinitionNode = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      selectionSet: queryDefinition.selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, query);\n  }\n}\n\nexport type WriteContext = {\n  store: NormalizedCache;\n  storeFactory: NormalizedCacheFactory;\n  processedData?: { [x: string]: FieldNode[] };\n  variables?: any;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport function writeResultToStore({\n  dataId,\n  result,\n  document,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMatcherFunction,\n}: {\n  dataId: string;\n  result: any;\n  document: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n  const operationDefinition = getOperationDefinition(document);\n  const selectionSet = operationDefinition.selectionSet;\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n\n  variables = assign({}, getDefaultValues(operationDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      result,\n      dataId,\n      selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, document);\n  }\n}\n\nexport function writeSelectionSetToStore({\n  result,\n  dataId,\n  selectionSet,\n  context,\n}: {\n  dataId: string;\n  result: any;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n}): NormalizedCache {\n  const { variables, store, fragmentMap } = context;\n\n  selectionSet.selections.forEach(selection => {\n    const included = shouldInclude(selection, variables);\n\n    if (isField(selection)) {\n      const resultFieldKey: string = resultKeyNameFromField(selection);\n      const value: any = result[resultFieldKey];\n\n      if (included) {\n        if (typeof value !== 'undefined') {\n          writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          // if this is a defered field we don't need to throw / warn\n          const isDefered =\n            selection.directives &&\n            selection.directives.length &&\n            selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\n                `Missing field ${resultFieldKey} in ${JSON.stringify(\n                  result,\n                  null,\n                  2,\n                ).substring(0, 100)}`,\n              );\n            }\n          }\n        }\n      }\n    } else {\n      // This is not a field, so it must be a fragment, either inline or named\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // Named fragment\n        fragment = (fragmentMap || {})[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}.`);\n        }\n      }\n\n      let matches = true;\n      if (context.fragmentMatcherFunction && fragment.typeCondition) {\n        // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n        // Right now we have to pretend that we're passing in an idValue and that there's a store\n        // on the context.\n        const idValue = toIdValue({ id: 'self', typename: undefined });\n        const fakeContext: ReadStoreContext = {\n          // NOTE: fakeContext always uses ObjectCache\n          // since this is only to ensure the return value of 'matches'\n          store: new ObjectCache({ self: result }),\n          returnPartialData: false,\n          hasMissingField: false,\n          cacheRedirects: {},\n        };\n        matches = context.fragmentMatcherFunction(\n          idValue,\n          fragment.typeCondition.name.value,\n          fakeContext,\n        );\n        if (!isProduction() && fakeContext.returnPartialData) {\n          console.error('WARNING: heuristic fragment matching going on!');\n        }\n      }\n\n      if (included && matches) {\n        writeSelectionSetToStore({\n          result,\n          selectionSet: fragment.selectionSet,\n          dataId,\n          context,\n        });\n      }\n    }\n  });\n\n  return store;\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n) {\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue)) {\n      mergeWithGenerated(value.id, realValue.id, cache);\n    }\n    cache.delete(generatedKey);\n    cache.set(realKey, { ...generated, ...real } as StoreObject);\n  });\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n\nfunction writeFieldToStore({\n  field,\n  value,\n  dataId,\n  context,\n}: {\n  field: FieldNode;\n  value: any;\n  dataId: string;\n  context: WriteContext;\n}) {\n  const { variables, dataIdFromObject, store } = context;\n\n  let storeValue: StoreValue;\n  let storeObject: StoreObject;\n\n  const storeFieldName: string = storeKeyNameFromField(field, variables);\n  // specifies if we need to merge existing keys in the store\n  let shouldMerge = false;\n  // If we merge, this will be the generatedKey\n  let generatedKey: string = '';\n\n  // If this is a scalar value...\n  if (!field.selectionSet || value === null) {\n    storeValue =\n      value != null && typeof value === 'object'\n        ? // If the scalar value is a JSON blob, we have to \"escape\" it so it cant pretend to be\n          // an id.\n          { type: 'json', json: value }\n        : // Otherwise, just store the scalar directly in the store.\n          value;\n  } else if (Array.isArray(value)) {\n    const generatedId = `${dataId}.${storeFieldName}`;\n\n    storeValue = processArrayValue(\n      value,\n      generatedId,\n      field.selectionSet,\n      context,\n    );\n  } else {\n    // It's an object\n    let valueDataId = `${dataId}.${storeFieldName}`;\n    let generated = true;\n\n    // We only prepend the '$' if the valueDataId isn't already a generated\n    // id.\n    if (!isGeneratedId(valueDataId)) {\n      valueDataId = '$' + valueDataId;\n    }\n\n    if (dataIdFromObject) {\n      const semanticId = dataIdFromObject(value);\n\n      // We throw an error if the first character of the id is '$. This is\n      // because we use that character to designate an Apollo-generated id\n      // and we use the distinction between user-desiginated and application-provided\n      // ids when managing overwrites.\n      if (semanticId && isGeneratedId(semanticId)) {\n        throw new Error(\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n      }\n\n      if (semanticId || (typeof semanticId === 'number' && semanticId === 0)) {\n        valueDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(valueDataId, field, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: valueDataId,\n        result: value,\n        selectionSet: field.selectionSet,\n        context,\n      });\n    }\n\n    // We take the id and escape it (i.e. wrap it with an enclosing object).\n    // This allows us to distinguish IDs from normal scalars.\n    const typename = value.__typename;\n    storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n    // check if there was a generated id at the location where we're\n    // about to place this new id. If there was, we have to merge the\n    // data from that id with the data we're about to write in the store.\n    storeObject = store.get(dataId);\n    const escapedId =\n      storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n    if (escapedId !== storeValue && isIdValue(escapedId)) {\n      const hadTypename = escapedId.typename !== undefined;\n      const hasTypename = typename !== undefined;\n      const typenameChanged =\n        hadTypename && hasTypename && escapedId.typename !== typename;\n\n      // If there is already a real id in the store and the current id we\n      // are dealing with is generated, we throw an error.\n      // One exception we allow is when the typename has changed, which occurs\n      // when schema defines a union, both with and without an ID in the same place.\n      // checks if we \"lost\" the read id\n      if (generated && !escapedId.generated && !typenameChanged) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided id` +\n            ` but the store already contains an id of ${\n              escapedId.id\n            } for this object. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n      // checks if we \"lost\" the typename\n      if (hadTypename && !hasTypename) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided typename` +\n            ` but the store already contains an object with typename of ${\n              escapedId.typename\n            } for the object of id ${escapedId.id}. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n\n      if (escapedId.generated) {\n        generatedKey = escapedId.id;\n        // We should only merge if it's an object of the same type,\n        // otherwise we should delete the generated object\n        if (typenameChanged) {\n          // Only delete the generated object when the old object was\n          // inlined, and the new object is not. This is indicated by\n          // the old id being generated, and the new id being real.\n          if (!generated) {\n            store.delete(generatedKey);\n          }\n        } else {\n          shouldMerge = true;\n        }\n      }\n    }\n  }\n\n  const newStoreObj = {\n    ...store.get(dataId),\n    [storeFieldName]: storeValue,\n  } as StoreObject;\n\n  if (shouldMerge) {\n    mergeWithGenerated(generatedKey, (storeValue as IdValue).id, store);\n  }\n\n  storeObject = store.get(dataId);\n  if (!storeObject || storeValue !== storeObject[storeFieldName]) {\n    store.set(dataId, newStoreObj);\n  }\n}\n\nfunction processArrayValue(\n  value: any[],\n  generatedId: string,\n  selectionSet: SelectionSetNode,\n  context: WriteContext,\n): any[] {\n  return value.map((item: any, index: any) => {\n    if (item === null) {\n      return null;\n    }\n\n    let itemDataId = `${generatedId}.${index}`;\n\n    if (Array.isArray(item)) {\n      return processArrayValue(item, itemDataId, selectionSet, context);\n    }\n\n    let generated = true;\n\n    if (context.dataIdFromObject) {\n      const semanticId = context.dataIdFromObject(item);\n\n      if (semanticId) {\n        itemDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: itemDataId,\n        result: item,\n        selectionSet,\n        context,\n      });\n    }\n\n    return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n  });\n}\n","import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues?: VariableMap,\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (!shouldInclude(selection, variables)) {\n      // Skip this entirely\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function merge(dest, src) {\n  if (src !== null && typeof src === 'object') {\n    Object.keys(src).forEach(key => {\n      const srcVal = src[key];\n      if (!hasOwn.call(dest, key)) {\n        dest[key] = srcVal;\n      } else {\n        merge(dest[key], srcVal);\n      }\n    });\n  }\n}\n","import graphqlAnywhere, { Resolver, ExecInfo } from 'graphql-anywhere';\n\nimport {\n  IdValue,\n  assign,\n  isEqual,\n  getDefaultValues,\n  getQueryDefinition,\n  isJsonValue,\n  isIdValue,\n  toIdValue,\n  getStoreKeyName,\n  StoreValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadQueryOptions,\n  IdValueWithPreviousResult,\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  StoreObject,\n} from './types';\n\n/**\n * The key which the cache id for a given value is stored in the result object. This key is private\n * and should not be used by Apollo client users.\n *\n * Uses a symbol if available in the environment.\n *\n * @private\n */\nexport const ID_KEY = typeof Symbol !== 'undefined' ? Symbol('id') : '@@id';\n\n/**\n * Resolves the result of a query solely from the store (i.e. never hits the server).\n *\n * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n * store.\n *\n * @param {DocumentNode} query The query document to resolve from the data available in the store.\n *\n * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n * be referenced by the query document.\n *\n * @param {any} previousResult The previous result returned by this function for the same query.\n * If nothing in the store changed since that previous result then values from the previous result\n * will be returned to preserve referential equality.\n */\nexport function readQueryFromStore<QueryType>(\n  options: ReadQueryOptions,\n): QueryType {\n  const optsPatch = { returnPartialData: false };\n\n  return diffQueryAgainstStore<QueryType>({\n    ...options,\n    ...optsPatch,\n  }).result;\n}\n\nconst readStoreResolver: Resolver = (\n  fieldName: string,\n  idValue: IdValueWithPreviousResult,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n) => {\n  assertIdValue(idValue);\n\n  const objId = idValue.id;\n  const obj = context.store.get(objId);\n\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | string | void = void 0;\n\n  if (obj) {\n    fieldValue = obj[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      (obj.__typename || objId === 'ROOT_QUERY')\n    ) {\n      const typename = obj.__typename || 'Query';\n\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(obj, args, {\n            getCacheKey(storeObj: StoreObject) {\n              return toIdValue({\n                id: context.dataIdFromObject(storeObj),\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    if (!context.returnPartialData) {\n      throw new Error(\n        `Can't find field ${storeKeyName} on object (${objId}) ${JSON.stringify(\n          obj,\n          null,\n          2,\n        )}.`,\n      );\n    }\n\n    context.hasMissingField = true;\n\n    return fieldValue;\n  }\n\n  // if this is an object scalar, it must be a json blob and we have to unescape it\n  if (isJsonValue(fieldValue)) {\n    // If the JSON blob is the same now as in the previous result, return the previous result to\n    // maintain referential equality.\n    //\n    // `isEqual` will first perform a referential equality check (with `===`) in case the JSON\n    // value has not changed in the store, and then a deep equality check if that fails in case a\n    // new JSON object was returned by the API but that object may still be the same.\n    if (\n      idValue.previousResult &&\n      isEqual(idValue.previousResult[resultKey], fieldValue.json)\n    ) {\n      return idValue.previousResult[resultKey];\n    }\n    return fieldValue.json;\n  }\n\n  // If we had a previous result, try adding that previous result value for this field to our field\n  // value. This will create a new value without mutating the old one.\n  if (idValue.previousResult) {\n    fieldValue = addPreviousResultToIdValues(\n      fieldValue,\n      idValue.previousResult[resultKey],\n    );\n  }\n\n  return fieldValue;\n};\n\n/**\n * Given a store and a query, return as much of the result as possible and\n * identify if any data was missing from the store.\n * @param  {DocumentNode} query A parsed GraphQL query document\n * @param  {Store} store The Apollo Client store object\n * @param  {any} previousResult The previous result returned by this function for the same query\n * @return {result: Object, complete: [boolean]}\n */\nexport function diffQueryAgainstStore<T>({\n  store,\n  query,\n  variables,\n  previousResult,\n  returnPartialData = true,\n  rootId = 'ROOT_QUERY',\n  fragmentMatcherFunction,\n  config,\n}: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n  // Throw the right validation error by trying to find a query in the document\n  const queryDefinition = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  const context: ReadStoreContext = {\n    // Global settings\n    store,\n    returnPartialData,\n    dataIdFromObject: (config && config.dataIdFromObject) || null,\n    cacheRedirects: (config && config.cacheRedirects) || {},\n    // Flag set during execution\n    hasMissingField: false,\n  };\n\n  const rootIdValue = {\n    type: 'id',\n    id: rootId,\n    previousResult,\n  };\n\n  const result = graphqlAnywhere(\n    readStoreResolver,\n    query,\n    rootIdValue,\n    context,\n    variables,\n    {\n      fragmentMatcher: fragmentMatcherFunction,\n      resultMapper,\n    },\n  );\n\n  return {\n    result: result as T,\n    complete: !context.hasMissingField,\n  };\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  if (!isIdValue(idValue)) {\n    throw new Error(`Encountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n  }\n}\n\n/**\n * Adds a previous result value to id values in a nested array. For a single id value and a single\n * previous result then the previous value is added directly.\n *\n * For arrays we put all of the ids from the previous result array in a map and add them to id\n * values with the same id.\n *\n * This function does not mutate. Instead it returns new instances of modified values.\n *\n * @private\n */\nfunction addPreviousResultToIdValues(value: any, previousResult: any): any {\n  // If the value is an `IdValue`, add the previous result to it whether or not that\n  // `previousResult` is undefined.\n  //\n  // If the value is an array, recurse over each item trying to add the `previousResult` for that\n  // item.\n  if (isIdValue(value)) {\n    return {\n      ...value,\n      previousResult,\n    };\n  } else if (Array.isArray(value)) {\n    const idToPreviousResult: Map<string, any> = new Map();\n\n    // If the previous result was an array, we want to build up our map of ids to previous results\n    // using the private `ID_KEY` property that is added in `resultMapper`.\n    if (Array.isArray(previousResult)) {\n      previousResult.forEach(item => {\n        // item can be null\n        if (item && item[ID_KEY]) {\n          idToPreviousResult.set(item[ID_KEY], item);\n          // idToPreviousResult[item[ID_KEY]] = item;\n        }\n      });\n    }\n\n    // For every value we want to add the previous result.\n    return value.map((item, i) => {\n      // By default the previous result for this item will be in the same array position as this\n      // item.\n      let itemPreviousResult = previousResult && previousResult[i];\n\n      // If the item is an id value, we should check to see if there is a previous result for this\n      // specific id. If there is, that will be the value for `itemPreviousResult`.\n      if (isIdValue(item)) {\n        itemPreviousResult =\n          idToPreviousResult.get(item.id) || itemPreviousResult;\n      }\n\n      return addPreviousResultToIdValues(item, itemPreviousResult);\n    });\n  }\n  // Return the value, nothing changed.\n  return value;\n}\n\n/**\n * Maps a result from `graphql-anywhere` to a final result value.\n *\n * If the result and the previous result from the `idValue` pass a shallow equality test, we just\n * return the `previousResult` to maintain referential equality.\n *\n * We also add a private id property to the result that we can use later on.\n *\n * @private\n */\nfunction resultMapper(resultFields: any, idValue: IdValueWithPreviousResult) {\n  // If we had a previous result, we may be able to return that and preserve referential equality\n  if (idValue.previousResult) {\n    const currentResultKeys = Object.keys(resultFields);\n\n    const sameAsPreviousResult =\n      // Confirm that we have the same keys in both the current result and the previous result.\n      Object.keys(idValue.previousResult).every(\n        key => currentResultKeys.indexOf(key) > -1,\n      ) &&\n      // Perform a shallow comparison of the result fields with the previous result. If all of\n      // the shallow fields are referentially equal to the fields of the previous result we can\n      // just return the previous result.\n      //\n      // While we do a shallow comparison of objects, but we do a deep comparison of arrays.\n      currentResultKeys.every(key =>\n        areNestedArrayItemsStrictlyEqual(\n          resultFields[key],\n          idValue.previousResult[key],\n        ),\n      );\n\n    if (sameAsPreviousResult) {\n      return idValue.previousResult;\n    }\n  }\n\n  Object.defineProperty(resultFields, ID_KEY, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: idValue.id,\n  });\n\n  return resultFields;\n}\n\ntype NestedArray<T> = T | Array<T | Array<T | Array<T>>>;\n\n/**\n * Compare all the items to see if they are all referentially equal in two arrays no matter how\n * deeply nested the arrays are.\n *\n * @private\n */\nfunction areNestedArrayItemsStrictlyEqual(\n  a: NestedArray<any>,\n  b: NestedArray<any>,\n): boolean {\n  // If `a` and `b` are referentially equal, return true.\n  if (a === b) {\n    return true;\n  }\n  // If either `a` or `b` are not an array or not of the same length return false. `a` and `b` are\n  // known to not be equal here, we checked above.\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  // Otherwise let us compare all of the array items (which are potentially nested arrays!) to see\n  // if they are equal.\n  return a.every((item, i) => areNestedArrayItemsStrictlyEqual(item, b[i]));\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class RecordingCache implements NormalizedCache {\n  private recordedData: NormalizedCacheObject = {};\n\n  constructor(private readonly data: NormalizedCacheObject = {}) {}\n\n  public record(\n    transaction: (recordingCache: RecordingCache) => void,\n  ): NormalizedCacheObject {\n    transaction(this);\n    const recordedData = this.recordedData;\n    this.recordedData = {};\n    return recordedData;\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data, ...this.recordedData };\n  }\n\n  public get(dataId: string): StoreObject {\n    if (this.recordedData.hasOwnProperty(dataId)) {\n      // recording always takes precedence:\n      return this.recordedData[dataId];\n    }\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    if (this.get(dataId) !== value) {\n      this.recordedData[dataId] = value;\n    }\n  }\n\n  public delete(dataId: string): void {\n    this.recordedData[dataId] = undefined;\n  }\n\n  public clear(): void {\n    Object.keys(this.data).forEach(dataId => this.delete(dataId));\n    this.recordedData = {};\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    this.clear();\n    this.recordedData = { ...newData };\n  }\n}\n\nexport function record(\n  startingState: NormalizedCacheObject,\n  transaction: (recordingCache: RecordingCache) => void,\n): NormalizedCacheObject {\n  const recordingCache = new RecordingCache(startingState);\n  return recordingCache.record(transaction);\n}\n","import { DocumentNode } from 'graphql';\n\nimport { Cache, DataProxy, ApolloCache, Transaction } from 'apollo-cache';\n\nimport {\n  getFragmentQueryDocument,\n  addTypenameToDocument,\n} from 'apollo-utilities';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  OptimisticStoreItem,\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\nimport { writeResultToStore } from './writeToStore';\nimport { readQueryFromStore, diffQueryAgainstStore } from './readFromStore';\nimport { defaultNormalizedCacheFactory } from './objectCache';\nimport { record } from './recordingCache';\nconst defaultConfig: ApolloReducerConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  storeFactory: defaultNormalizedCacheFactory,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  protected data: NormalizedCache;\n  protected config: ApolloReducerConfig;\n  protected optimistic: OptimisticStoreItem[] = [];\n  private watches: Cache.WatchOptions[] = [];\n  private addTypename: boolean;\n  private typenameDocumentCache = new WeakMap<DocumentNode, DocumentNode>();\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: ApolloReducerConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      console.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      console.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = this.config.addTypename;\n    this.data = this.config.storeFactory();\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    if (optimistic && this.optimistic.length > 0) {\n      const patches = this.optimistic.map(opt => opt.data);\n      return Object.assign({}, this.data.toObject(), ...patches);\n    }\n\n    return this.data.toObject();\n  }\n\n  public read<T>(query: Cache.ReadOptions): T | null {\n    if (query.rootId && this.data.get(query.rootId) === undefined) {\n      return null;\n    }\n\n    return readQueryFromStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      rootId: query.rootId,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      previousResult: query.previousResult,\n      config: this.config,\n    });\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    return diffQueryAgainstStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.push(watch);\n\n    return () => {\n      this.watches = this.watches.filter(c => c !== watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new Error(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(id: string) {\n    // Throw away optimistic changes of that particular mutation\n    const toPerform = this.optimistic.filter(item => item.id !== id);\n\n    this.optimistic = [];\n\n    // Re-run all of our optimistic data actions on top of one another.\n    toPerform.forEach(change => {\n      this.recordOptimisticTransaction(change.transaction, change.id);\n    });\n\n    this.broadcastWatches();\n  }\n\n  public performTransaction(transaction: Transaction<NormalizedCacheObject>) {\n    // TODO: does this need to be different, or is this okay for an in-memory cache?\n\n    let alreadySilenced = this.silenceBroadcast;\n    this.silenceBroadcast = true;\n\n    transaction(this);\n\n    if (!alreadySilenced) {\n      // Don't un-silence since this is a nested transaction\n      // (for example, a transaction inside an optimistic record)\n      this.silenceBroadcast = false;\n    }\n\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    this.silenceBroadcast = true;\n\n    const patch = record(this.extract(true), recordingCache => {\n      // swapping data instance on 'this' is currently necessary\n      // because of the current architecture\n      const dataCache = this.data;\n      this.data = recordingCache;\n      this.performTransaction(transaction);\n      this.data = dataCache;\n    });\n\n    this.optimistic.push({\n      id,\n      transaction,\n      data: patch,\n    });\n\n    this.silenceBroadcast = false;\n\n    this.broadcastWatches();\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        this.typenameDocumentCache.set(\n          document,\n          (result = addTypenameToDocument(document)),\n        );\n      }\n      return result;\n    }\n    return document;\n  }\n\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n    });\n  }\n\n  protected broadcastWatches() {\n    // Skip this when silenced (like inside a transaction)\n    if (this.silenceBroadcast) return;\n\n    // right now, we invalidate all queries whenever anything changes\n    this.watches.forEach((c: Cache.WatchOptions) => {\n      const newData = this.diff({\n        query: c.query,\n        variables: c.variables,\n\n        // TODO: previousResult isn't in the types - this will only work\n        // with ObservableQuery which is in a different package\n        previousResult: (c as any).previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      });\n\n      c.callback(newData);\n    });\n  }\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = Error & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: GlobalFetch['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: GlobalFetch['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new Error(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new Error(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch is nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: context.headers,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so its already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we dont' call next, the UI can only show networkError because AC didn't\n            // get andy graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n","import { Data, Field } from \"../support/interfaces\";\nimport Model from \"../orm/model\";\nimport { Model as ORMModel } from \"@vuex-orm/core\";\nimport Context from \"../common/context\";\nimport { clone, downcaseFirstLetter, isPlainObject } from \"../support/utils\";\nconst inflection = require(\"inflection\");\n\n/**\n * This class provides methods to transform incoming data from GraphQL in to a format Vuex-ORM understands and\n * vice versa.\n */\nexport default class Transformer {\n  /**\n   * Transforms outgoing data. Use for variables param.\n   *\n   * Omits relations and some other fields.\n   *\n   * @param model\n   * @param {Data} data\n   * @param {Array<String>} whitelist of fields\n   * @returns {Data}\n   */\n  public static transformOutgoingData(model: Model, data: Data, whitelist?: Array<String>): Data {\n    const context = Context.getInstance();\n    const relations: Map<string, Field> = model.getRelations();\n    const returnValue: Data = {};\n\n    Object.keys(data).forEach(key => {\n      const value = data[key];\n\n      if (key === \"comments\") {\n        console.log(\"model\", model, model.baseModel.$entitiy, model.constructor.name);\n        console.log(\"data\", data);\n        console.log(\"whitelist\", whitelist);\n      }\n\n      // Always add fields on the whitelist. Ignore hasMany/One connections, empty fields and internal fields ($)\n      if (\n        (whitelist && whitelist.includes(key)) ||\n        ((!relations.has(key) || relations.get(key) instanceof context.components.BelongsTo) &&\n          !key.startsWith(\"$\") &&\n          value !== null &&\n          value !== undefined)\n      ) {\n        let relatedModel =\n          relations.get(key) && relations.get(key)!.parent\n            ? context.getModel(inflection.singularize(relations.get(key)!.parent!.entity), true)\n            : null;\n        if (value instanceof Array) {\n          // Iterate over all fields and transform them if value is an array\n          const arrayModel = context.getModel(inflection.singularize(key));\n          returnValue[key] = value.map(v => this.transformOutgoingData(arrayModel || model, v));\n        } else if (typeof value === \"object\" && value.$id !== undefined) {\n          if (!relatedModel) {\n            relatedModel = context.getModel((value as ORMModel).$self().entity);\n          }\n\n          // Value is a record, transform that too\n          returnValue[key] = this.transformOutgoingData(relatedModel, value);\n        } else {\n          // In any other case just let the value be what ever it is\n          returnValue[key] = value;\n        }\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Transforms a set of incoming data to the format vuex-orm requires.\n   *\n   * @param {Data | Array<Data>} data\n   * @param model\n   * @param mutation required to transform something like `disableUserAddress` to the actual model name.\n   * @param {boolean} recursiveCall\n   * @returns {Data}\n   */\n  public static transformIncomingData(\n    data: Data | Array<Data>,\n    model: Model,\n    mutation: boolean = false,\n    recursiveCall: boolean = false\n  ): Data {\n    let result: Data = {};\n    const context = Context.getInstance();\n\n    if (!recursiveCall) {\n      context.logger.group(\"Transforming incoming data\");\n      context.logger.log(\"Raw data:\", data);\n    }\n\n    if (Array.isArray(data)) {\n      result = data.map((d: any) => this.transformIncomingData(d, model, mutation, true));\n    } else {\n      Object.keys(data).forEach(key => {\n        if (data[key] !== undefined && data[key] !== null) {\n          if (isPlainObject(data[key])) {\n            const localModel: Model = context.getModel(key, true) || model;\n\n            if (data[key].nodes && context.connectionQueryMode === \"nodes\") {\n              result[inflection.pluralize(key)] = this.transformIncomingData(\n                data[key].nodes,\n                localModel,\n                mutation,\n                true\n              );\n            } else if (data[key].edges && context.connectionQueryMode === \"edges\") {\n              result[inflection.pluralize(key)] = this.transformIncomingData(\n                data[key].edges,\n                localModel,\n                mutation,\n                true\n              );\n            } else if (data[\"node\"] && context.connectionQueryMode === \"edges\") {\n              result = this.transformIncomingData(data[\"node\"], localModel, mutation, true);\n            } else {\n              let newKey = key;\n\n              if (mutation && !recursiveCall) {\n                newKey = data[key].nodes ? localModel.pluralName : localModel.singularName;\n                newKey = downcaseFirstLetter(newKey);\n              }\n\n              result[newKey] = this.transformIncomingData(data[key], localModel, mutation, true);\n            }\n          } else if (Model.isFieldNumber(model.fields.get(key))) {\n            result[key] = parseFloat(data[key]);\n          } else if (key.endsWith(\"Type\") && model.isTypeFieldOfPolymorphicRelation(key)) {\n            result[key] = inflection.pluralize(downcaseFirstLetter(data[key]));\n          } else {\n            result[key] = data[key];\n          }\n        }\n      });\n    }\n\n    if (!recursiveCall) {\n      context.logger.log(\"Transformed data:\", result);\n      context.logger.groupEnd();\n    } else {\n      result[\"$isPersisted\"] = true;\n    }\n\n    // Make sure this is really a plain JS object. We had some issues in testing here.\n    return clone(result);\n  }\n}\n","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","import { ApolloClient, FetchPolicy } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport { ApolloLink } from 'apollo-link';\nimport Context from '../common/context';\nimport { Arguments, Data } from '../support/interfaces';\nimport Transformer from './transformer';\nimport Model from '../orm/model';\nimport gql from 'graphql-tag';\n\n/**\n * This class takes care of the communication with the graphql endpoint by leveraging the awesome apollo-client lib.\n */\nexport default class Apollo {\n  /**\n   * The http link instance to use.\n   * @type {HttpLink}\n   */\n  private readonly httpLink: ApolloLink;\n\n  /**\n   * The ApolloClient instance\n   * @type {ApolloClient}\n   */\n  private readonly apolloClient: ApolloClient<any>;\n\n  /**\n   * @constructor\n   */\n  public constructor () {\n    const context = Context.getInstance();\n\n    // This allows the test suite to pass a custom link\n    if (context.options.link) {\n      this.httpLink = context.options.link;\n    } else {\n      this.httpLink = new HttpLink({\n        uri: context.options.url ? context.options.url : '/graphql',\n        credentials: context.options.credentials ? context.options.credentials : 'same-origin',\n        useGETForQueries: Boolean(context.options.useGETForQueries)\n      });\n    }\n\n    this.apolloClient = new ApolloClient({\n      link: this.httpLink,\n      cache: new InMemoryCache(),\n      connectToDevTools: context.debugMode\n    });\n  }\n\n  /**\n   * Sends a request to the GraphQL API via apollo\n   * @param model\n   * @param {any} query The query to send (result from gql())\n   * @param {Arguments} variables Optional. The variables to send with the query\n   * @param {boolean} mutation Optional. If this is a mutation (true) or a query (false, default)\n   * @param {boolean} bypassCache If true the query will be send to the server without using the cache. For queries only\n   * @returns {Promise<Data>} The new records\n   */\n  public async request (model: Model, query: any, variables?: Arguments, mutation: boolean = false,\n                        bypassCache: boolean = false): Promise<Data> {\n\n    const fetchPolicy: FetchPolicy = bypassCache ? 'network-only' : 'cache-first';\n    Context.getInstance().logger.logQuery(query, variables, fetchPolicy);\n\n    const context = { headers: Apollo.getHeaders() };\n\n    let response;\n    if (mutation) {\n      response = await this.apolloClient.mutate({ mutation: query, variables, context });\n    } else {\n      response = await this.apolloClient.query({ query, variables, fetchPolicy, context });\n    }\n\n    // Transform incoming data into something useful\n    return Transformer.transformIncomingData(response.data as Data, model, mutation);\n  }\n\n  public async simpleQuery (query: string, variables: Arguments, bypassCache: boolean = false, context?: Data): Promise<any> {\n    const fetchPolicy: FetchPolicy = bypassCache ? 'network-only' : 'cache-first';\n    return this.apolloClient.query({ query: gql(query), variables, fetchPolicy, context: { headers: Apollo.getHeaders() } });\n  }\n\n  public async simpleMutation (query: string, variables: Arguments, context?: Data): Promise<any> {\n    return this.apolloClient.mutate({ mutation: gql(query), variables, context: { headers: Apollo.getHeaders() } });\n  }\n\n  private static getHeaders () {\n    const context = Context.getInstance();\n\n    let headers: Object | Function = context.options.headers ? context.options.headers : {};\n\n    if (headers instanceof Function) {\n      headers = headers(context);\n    }\n\n    return headers;\n  }\n}\n","import { GraphQLField, GraphQLSchema, GraphQLType, GraphQLTypeDefinition } from '../support/interfaces';\nimport { upcaseFirstLetter } from '../support/utils';\n\nexport default class Schema {\n  private schema: GraphQLSchema;\n  private types: Map<string, GraphQLType>;\n  private mutations: Map<string, GraphQLField>;\n  private queries: Map<string, GraphQLField>;\n\n  public constructor (schema: GraphQLSchema) {\n    this.schema = schema;\n    this.types = new Map<string, GraphQLType>();\n    this.mutations = new Map<string, GraphQLField>();\n    this.queries = new Map<string, GraphQLField>();\n\n    this.schema.types.forEach((t: GraphQLType) => this.types.set(t.name, t));\n\n    this.getType('Query')!.fields!.forEach(f => this.queries.set(f.name, f));\n    this.getType('Mutation')!.fields!.forEach(f => this.mutations.set(f.name, f));\n  }\n\n  public determineQueryMode (): string {\n    let connection: GraphQLType | null = null;\n\n    this.queries.forEach((query) => {\n      const typeName = Schema.getTypeNameOfField(query);\n      if (typeName.endsWith('TypeConnection')) {\n        connection = this.getType(typeName);\n        return false; // break\n      }\n      return true;\n    });\n\n    if (!connection) {\n      throw new Error(\"Can't determine the connection mode due to the fact that here are no connection types in the schema. Please set the connectionQueryMode via Vuex-ORM-GraphQL options!\");\n    }\n\n    if (connection!.fields!.find(f => f.name === 'nodes')) {\n      return 'nodes';\n    } else if (connection!.fields!.find(f => f.name === 'edges')) {\n      return 'edges';\n    } else {\n      return 'plain';\n    }\n  }\n\n  public getType (name: string, allowNull: boolean = false): GraphQLType | null {\n    name = upcaseFirstLetter(name);\n    const type = this.types.get(name);\n\n    if (!allowNull && !type) throw new Error(`Couldn't find Type of name ${name} in the GraphQL Schema.`);\n\n    return type || null;\n  }\n\n  public getMutation (name: string, allowNull: boolean = false): GraphQLField | null {\n    const mutation = this.mutations.get(name);\n\n    if (!allowNull && !mutation) throw new Error(`Couldn't find Mutation of name ${name} in the GraphQL Schema.`);\n\n    return mutation || null;\n  }\n\n  public getQuery (name: string, allowNull: boolean = false): GraphQLField | null {\n    const query = this.queries.get(name);\n\n    if (!allowNull && !query) throw new Error(`Couldn't find Query of name ${name} in the GraphQL Schema.`);\n\n    return query || null;\n  }\n\n  static returnsConnection (field: GraphQLField): boolean {\n    return (Schema.getTypeNameOfField(field).endsWith('TypeConnection'));\n  }\n\n  static getRealType (type: GraphQLTypeDefinition): GraphQLTypeDefinition {\n    if (type.kind === 'NON_NULL') {\n      return this.getRealType(type.ofType);\n    } else {\n      return type;\n    }\n  }\n\n  static getTypeNameOfField (field: GraphQLField): string {\n    const type = this.getRealType(field.type);\n\n    if (type.kind === 'LIST') {\n      return `[${type.ofType.name}]`;\n    }\n\n    const name = type.name || type.ofType.name || type.ofType.ofType.name;\n\n    if (!name) throw new Error(`Can't find type name for field ${field.name}`);\n\n    return name;\n  }\n}\n","import Logger from \"./logger\";\nimport Model from \"../orm/model\";\nimport { Model as ORMModel } from \"@vuex-orm/core\";\nimport { Components } from \"@vuex-orm/core/lib/plugins/use\";\nimport { downcaseFirstLetter, isEqual, pick } from \"../support/utils\";\nimport Apollo from \"../graphql/apollo\";\nimport Database from \"@vuex-orm/core/lib/database/Database\";\nimport { Field, GraphQLType, Options } from \"../support/interfaces\";\nimport Schema from \"../graphql/schema\";\nimport { Mock, MockOptions } from \"../test-utils\";\nconst inflection = require(\"inflection\");\n\nconst introspectionQuery = `\nquery Introspection {\n  __schema {\n    types {\n      name\n      description\n      fields(includeDeprecated: true) {\n        name\n        description\n        args {\n          name\n          description\n          type {\n            name\n            kind\n\n            ofType {\n              kind\n\n              name\n              ofType {\n                kind\n                name\n\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n\n        type {\n          name\n          kind\n\n          ofType {\n            kind\n\n            name\n            ofType {\n              kind\n              name\n\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n\n      inputFields {\n        name\n        description\n        type {\n          name\n          kind\n\n          ofType {\n            kind\n\n            name\n            ofType {\n              kind\n              name\n\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`;\n\n/**\n * Internal context of the plugin. This class contains all information, the models, database, logger and so on.\n *\n * It's a singleton class, so just call Context.getInstance() anywhere you need the context.\n */\nexport default class Context {\n  /**\n   * Contains the instance for the singleton pattern.\n   * @type {Context}\n   */\n  public static instance: Context;\n\n  /**\n   * Components collection of Vuex-ORM\n   * @type {Components}\n   */\n  public readonly components: Components;\n\n  /**\n   * The options which have been passed to VuexOrm.install\n   * @type {Options}\n   */\n  public readonly options: Options;\n\n  /**\n   * The Vuex-ORM database\n   * @type {Database}\n   */\n  public readonly database: Database;\n\n  /**\n   * Collection of all Vuex-ORM models wrapped in a Model instance.\n   * @type {Map<any, any>}\n   */\n  public readonly models: Map<string, Model> = new Map();\n\n  /**\n   * When true, the logging is enabled.\n   * @type {boolean}\n   */\n  public readonly debugMode: boolean = false;\n\n  /**\n   * Our nice Vuex-ORM-GraphQL logger\n   * @type {Logger}\n   */\n  public readonly logger: Logger;\n\n  /**\n   * Instance of Apollo which cares about the communication with the graphql endpoint.\n   * @type {Apollo}\n   */\n  public apollo!: Apollo;\n\n  /**\n   * The graphql schema. Is null until the first request.\n   * @type {Schema}\n   */\n  public schema: Schema | undefined;\n\n  /**\n   * Tells if the schema is already loaded or the loading is currently processed.\n   * @type {boolean}\n   */\n  private schemaWillBeLoaded: Promise<Schema> | undefined;\n\n  /**\n   * Defines how to query connections. 'auto' | 'nodes' | 'edges' | 'plain'\n   */\n  public connectionQueryMode: string = \"auto\";\n\n  /**\n   * Container for the global mocks.\n   * @type {Object}\n   */\n  private globalMocks: { [key: string]: Array<Mock> } = {};\n\n  /**\n   * Private constructor, called by the setup method\n   *\n   * @constructor\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   */\n  private constructor(components: Components, options: Options) {\n    this.components = components;\n    this.options = options;\n\n    this.database = options.database;\n    this.debugMode = Boolean(options.debug);\n    this.logger = new Logger(this.debugMode);\n\n    if (!options.database) {\n      throw new Error(\"database param is required to initialize vuex-orm-graphql!\");\n    }\n  }\n\n  /**\n   * Get the singleton instance of the context.\n   * @returns {Context}\n   */\n  public static getInstance(): Context {\n    return this.instance;\n  }\n\n  /**\n   * This is called only once and creates a new instance of the Context.\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   * @returns {Context}\n   */\n  public static setup(components: Components, options: Options): Context {\n    this.instance = new Context(components, options);\n\n    this.instance.apollo = new Apollo();\n    this.instance.collectModels();\n\n    this.instance.logger.group(\"Context setup\");\n    this.instance.logger.log(\"components\", this.instance.components);\n    this.instance.logger.log(\"options\", this.instance.options);\n    this.instance.logger.log(\"database\", this.instance.database);\n    this.instance.logger.log(\"models\", this.instance.models);\n    this.instance.logger.groupEnd();\n\n    return this.instance;\n  }\n\n  public async loadSchema(): Promise<Schema> {\n    if (!this.schemaWillBeLoaded) {\n      this.schemaWillBeLoaded = new Promise(async (resolve, reject) => {\n        this.logger.log(\"Fetching GraphQL Schema initially ...\");\n\n        if (this.options.connectionQueryMode) {\n          this.connectionQueryMode = this.options.connectionQueryMode;\n        } else {\n          this.connectionQueryMode = \"auto\";\n        }\n\n        // We send a custom header along with the request. This is required for our test suite to mock the schema request.\n        const context = {\n          headers: { \"X-GraphQL-Introspection-Query\": \"true\" }\n        };\n\n        const result = await this.apollo.simpleQuery(introspectionQuery, {}, true, context);\n        this.schema = new Schema(result.data.__schema);\n\n        this.logger.log(\"GraphQL Schema successful fetched\", result);\n\n        this.logger.log(\"Starting to process the schema ...\");\n        this.processSchema();\n        this.logger.log(\"Schema procession done!\");\n\n        resolve(this.schema);\n      });\n    }\n\n    return this.schemaWillBeLoaded;\n  }\n\n  public processSchema() {\n    this.models.forEach((model: Model) => {\n      let type: GraphQLType;\n\n      try {\n        type = this.schema!.getType(model.singularName)!;\n      } catch (error) {\n        this.logger.warn(`Ignoring entity ${model.singularName} because it's not in the schema.`);\n        return;\n      }\n\n      model.fields.forEach((field: Field, fieldName: string) => {\n        if (!type.fields!.find(f => f.name === fieldName)) {\n          this.logger.warn(\n            `Ignoring field ${model.singularName}.${fieldName} because it's not in the schema.`\n          );\n\n          // TODO: Move skipFields to the model\n          model.baseModel.skipFields = model.baseModel.skipFields ? model.baseModel.skipFields : [];\n          if (!model.baseModel.skipFields.includes(fieldName)) {\n            model.baseModel.skipFields.push(fieldName);\n          }\n        }\n      });\n    });\n\n    if (this.connectionQueryMode === \"auto\") {\n      this.connectionQueryMode = this.schema!.determineQueryMode();\n      this.logger.log(\n        `Connection Query Mode is ${this.connectionQueryMode} by automatic detection`\n      );\n    } else {\n      this.logger.log(`Connection Query Mode is ${this.connectionQueryMode} by config`);\n    }\n  }\n\n  /**\n   * Returns a model from the model collection by it's name\n   *\n   * @param {Model|string} model A Model instance, a singular or plural name of the model\n   * @param {boolean} allowNull When true this method returns null instead of throwing an exception when no model was\n   *                            found. Default is false\n   * @returns {Model}\n   */\n  public getModel(model: Model | string, allowNull: boolean = false): Model {\n    if (typeof model === \"string\") {\n      const name: string = inflection.singularize(downcaseFirstLetter(model));\n      model = this.models.get(name) as Model;\n      if (!allowNull && !model) throw new Error(`No such model ${name}!`);\n    }\n\n    return model;\n  }\n\n  /**\n   * Will add a mock for simple mutations or queries. These are model unrelated and have to be\n   * handled  globally.\n   *\n   * @param {Mock} mock - Mock config.\n   */\n  public addGlobalMock(mock: Mock): boolean {\n    if (this.findGlobalMock(mock.action, mock.options)) return false;\n    if (!this.globalMocks[mock.action]) this.globalMocks[mock.action] = [];\n\n    this.globalMocks[mock.action].push(mock);\n    return true;\n  }\n\n  /**\n   * Finds a global mock for the given action and options.\n   *\n   * @param {string} action - Name of the action like 'simpleQuery' or 'simpleMutation'.\n   * @param {MockOptions} options - MockOptions like { name: 'example' }.\n   * @returns {Mock | null} null when no mock was found.\n   */\n  public findGlobalMock(action: string, options: MockOptions | undefined): Mock | null {\n    if (this.globalMocks[action]) {\n      return (\n        this.globalMocks[action].find(m => {\n          if (!m.options || !options) return true;\n\n          const relevantOptions = pick(options, Object.keys(m.options));\n          return isEqual(relevantOptions, m.options || {});\n        }) || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Hook to be called by simpleMutation and simpleQuery actions in order to get the global mock\n   * returnValue.\n   *\n   * @param {string} action - Name of the action like 'simpleQuery' or 'simpleMutation'.\n   * @param {MockOptions} options - MockOptions.\n   * @returns {any} null when no mock was found.\n   */\n  public globalMockHook(action: string, options: MockOptions): any {\n    let returnValue: null | { [key: string]: any } = null;\n    const mock = this.findGlobalMock(action, options);\n\n    if (mock) {\n      if (mock.returnValue instanceof Function) {\n        returnValue = mock.returnValue();\n      } else {\n        returnValue = mock.returnValue || null;\n      }\n    }\n\n    return returnValue;\n  }\n\n  /**\n   * Wraps all Vuex-ORM entities in a Model object and saves them into this.models\n   */\n  private collectModels() {\n    this.database.entities.forEach((entity: any) => {\n      const model: Model = new Model(entity.model as ORMModel);\n      this.models.set(model.singularName, model);\n      Model.augment(model);\n    });\n  }\n}\n","import Model from \"../orm/model\";\nimport { Arguments, Field, GraphQLField } from \"../support/interfaces\";\nimport { clone, isPlainObject, takeWhile, upcaseFirstLetter } from \"../support/utils\";\nimport gql from \"graphql-tag\";\nimport Context from \"../common/context\";\nimport Schema from \"./schema\";\n\n/**\n * Contains all logic to build GraphQL queries/mutations.\n */\nexport default class QueryBuilder {\n  /**\n   * Builds a field for the GraphQL query and a specific model\n   *\n   * @param {Model|string} model The model to use\n   * @param {boolean} multiple Determines whether plural/nodes syntax or singular syntax is used.\n   * @param {Arguments} args The args that will be passed to the query field ( user(role: $role) )\n   * @param {Array<Model>} path The relations in this list are ignored (while traversing relations).\n   *                                    Mainly for recursion\n   * @param {string} name Optional name of the field. If not provided, this will be the model name\n   * @param filter\n   * @param {boolean} allowIdFields Optional. Determines if id fields will be ignored for the argument generation.\n   *                                See buildArguments\n   * @returns {string}\n   *\n   * @todo Do we need the allowIdFields param?\n   */\n  public static buildField(\n    model: Model | string,\n    multiple: boolean = true,\n    args?: Arguments,\n    path: Array<string> = [],\n    name?: string,\n    filter: boolean = false,\n    allowIdFields: boolean = false\n  ): string {\n    const context = Context.getInstance();\n    model = context.getModel(model);\n\n    name = name ? name : model.pluralName;\n    const field = context.schema!.getMutation(name, true) || context.schema!.getQuery(name, true);\n\n    let params: string = this.buildArguments(model, args, false, filter, allowIdFields, field);\n    path = path.length === 0 ? [model.singularName] : path;\n\n    const fields = `\n      ${model.getQueryFields().join(\" \")}\n      ${this.buildRelationsQuery(model, path)}\n    `;\n\n    if (multiple) {\n      const header: string = `${name}${params}`;\n\n      if (context.connectionQueryMode === \"nodes\") {\n        return `\n          ${header} {\n            nodes {\n              ${fields}\n            }\n          }\n        `;\n      } else if (context.connectionQueryMode === \"edges\") {\n        return `\n          ${header} {\n            edges {\n              node {\n                ${fields}\n              }\n            }\n          }\n        `;\n      } else {\n        return `\n          ${header} {\n            ${fields}\n          }\n        `;\n      }\n    } else {\n      return `\n        ${name ? name : model.singularName}${params} {\n          ${fields}\n        }\n      `;\n    }\n  }\n\n  /**\n   * Generates a query.\n   * Currently only one root field for the query is possible.\n   * @param {string} type 'mutation' or 'query'\n   * @param {Model | string} model The model this query or mutation affects. This mainly determines the query fields.\n   * @param {string} name Optional name of the query/mutation. Will overwrite the name from the model.\n   * @param {Arguments} args Arguments for the query\n   * @param {boolean} multiple Determines if the root query field is a connection or not (will be passed to buildField)\n   * @param {boolean} filter When true the query arguments are passed via a filter object.\n   * @returns {any} Whatever gql() returns\n   */\n  public static buildQuery(\n    type: string,\n    model: Model | string,\n    name?: string,\n    args?: Arguments,\n    multiple?: boolean,\n    filter?: boolean\n  ) {\n    const context = Context.getInstance();\n\n    // model\n    model = context.getModel(model);\n    if (!model) throw new Error(\"No model provided to build the query!\");\n\n    // args\n    args = args ? clone(args) : {};\n    if (!args) throw new Error(\"args is undefined\");\n\n    Object.keys(args).forEach((key: string) => {\n      if (args && args[key] && isPlainObject(args[key])) {\n        args[key] = { __type: upcaseFirstLetter(key) };\n      }\n    });\n\n    // multiple\n    multiple = multiple === undefined ? !args[\"id\"] : multiple;\n\n    // name\n    if (!name) name = multiple ? model.pluralName : model.singularName;\n\n    // field\n    const field = context.schema!.getMutation(name, true) || context.schema!.getQuery(name, true);\n\n    // build query\n    const query: string =\n      `${type} ${upcaseFirstLetter(name)}${this.buildArguments(\n        model,\n        args,\n        true,\n        filter,\n        true,\n        field\n      )} {\\n` +\n      `  ${this.buildField(model, multiple, args, [], name, filter, true)}\\n` +\n      `}`;\n\n    return gql(query);\n  }\n\n  /**\n   * Generates the arguments string for a graphql query based on a given map.\n   *\n   * There are three types of arguments:\n   *\n   * 1) Signatures with primitive types (signature = true)\n   *      => 'mutation createUser($name: String!)'\n   *\n   * 2) Signatures with object types (signature = true, args = { user: { __type: 'User' }})\n   *      => 'mutation createUser($user: UserInput!)'\n   *\n   * 3) Fields with variables (signature = false)\n   *      => 'user(id: $id)'\n   *\n   * 4) Filter fields with variables (signature = false, filter = true)\n   *      => 'users(filter: { active: $active })'\n   *\n   * @param model\n   * @param {Arguments | undefined} args\n   * @param {boolean} signature When true, then this method generates a query signature instead of key/value pairs\n   * @param filter\n   * @param {boolean} allowIdFields If true, ID fields will be included in the arguments list\n   * @param {GraphQLField} field Optional. The GraphQL mutation or query field\n   * @returns {String}\n   */\n  public static buildArguments(\n    model: Model,\n    args?: Arguments,\n    signature: boolean = false,\n    filter: boolean = false,\n    allowIdFields: boolean = true,\n    field: GraphQLField | null = null\n  ): string {\n    if (args === undefined) return \"\";\n\n    let returnValue: string = \"\";\n    let first: boolean = true;\n\n    if (args) {\n      Object.keys(args).forEach((key: string) => {\n        let value: any = args[key];\n\n        const isForeignKey = model.skipField(key);\n        const skipFieldDueId = (key === \"id\" || isForeignKey) && !allowIdFields;\n\n        let schemaField: GraphQLField | undefined = this.findSchemaFieldForArgument(\n          key,\n          field,\n          model,\n          filter\n        );\n\n        const isConnectionField =\n          schemaField && Schema.getTypeNameOfField(schemaField).endsWith(\"TypeConnection\");\n\n        // Ignore null fields, ids and connections\n        if (value && !skipFieldDueId && !isConnectionField) {\n          let typeOrValue: any = \"\";\n\n          if (signature) {\n            if (isPlainObject(value) && value.__type) {\n              // Case 2 (User!)\n              typeOrValue = value.__type + \"Input!\";\n            } else if (Array.isArray(value) && field) {\n              const arg = QueryBuilder.findSchemaFieldForArgument(key, field, model, filter);\n              if (!arg) {\n                throw new Error(\n                  `The argument ${key} is of type array but it's not possible to determine the type, because it's not in the field ${\n                    field.name\n                  }`\n                );\n              }\n\n              typeOrValue = Schema.getTypeNameOfField(arg) + \"!\";\n            } else if (schemaField && Schema.getTypeNameOfField(schemaField)) {\n              // Case 1, 3 and 4\n              typeOrValue = Schema.getTypeNameOfField(schemaField) + \"!\";\n            } else if (key === \"id\" || isForeignKey) {\n              // Case 1 (ID!)\n              typeOrValue = \"ID!\";\n            } else {\n              // Case 1 (String!)\n              typeOrValue = this.determineAttributeType(model, key, value, field || undefined);\n              typeOrValue = typeOrValue + \"!\";\n            }\n          } else {\n            // Case 3 or 4\n            typeOrValue = `$${key}`;\n          }\n\n          returnValue = `${returnValue}${first ? \"\" : \", \"}${(signature ? \"$\" : \"\") +\n            key}: ${typeOrValue}`;\n\n          first = false;\n        }\n      });\n\n      if (!first) {\n        if (!signature && filter) returnValue = `filter: { ${returnValue} }`;\n        returnValue = `(${returnValue})`;\n      }\n    }\n\n    return returnValue;\n  }\n\n  /**\n   * Determines the GraphQL primitive type of a field in the variables hash by the field type or (when\n   * the field type is generic attribute) by the variable type.\n   * @param {Model} model\n   * @param {string} key\n   * @param {string} value\n   * @param {GraphQLField} query Pass when we have to detect the type of an argument\n   * @returns {string}\n   */\n  public static determineAttributeType(\n    model: Model,\n    key: string,\n    value: any,\n    query?: GraphQLField\n  ): string {\n    const context: Context = Context.getInstance();\n    const field: undefined | Field = model.fields.get(key);\n    let schemaField: undefined | GraphQLField;\n\n    if (query) {\n      schemaField = query.args.find(f => f.name === key);\n\n      if (!schemaField) {\n        const filterField = query.args.find(f => f.name === \"filter\");\n\n        if (filterField) {\n          schemaField = this.findSchemaFieldForArgument(key, null, model, true);\n        }\n      }\n    } else {\n      schemaField = context.schema!.getType(model.singularName)!.fields!.find(f => f.name === key);\n    }\n\n    if (schemaField && Schema.getTypeNameOfField(schemaField)) {\n      return Schema.getTypeNameOfField(schemaField);\n    } else {\n      if (field instanceof context.components.String) {\n        return \"String\";\n      } else if (field && field instanceof context.components.Number) {\n        return \"Int\";\n      } else if (field && field instanceof context.components.Boolean) {\n        return \"Boolean\";\n      } else {\n        if (typeof value === \"number\") return \"Int\";\n        if (typeof value === \"string\") return \"String\";\n        if (typeof value === \"boolean\") return \"Boolean\";\n\n        throw new Error(\n          `Can't find suitable graphql type for field '${model.singularName}.${key}'.`\n        );\n      }\n    }\n  }\n\n  private static findSchemaFieldForArgument(\n    name: String,\n    field: GraphQLField | null,\n    model: Model,\n    isFilter: boolean\n  ): GraphQLField | undefined {\n    const schema = Context.getInstance().schema!;\n    let schemaField: GraphQLField | undefined;\n\n    if (field) {\n      schemaField = field.args.find(f => f.name === name);\n      if (schemaField) return schemaField;\n    }\n\n    // We try to find the FilterType or at least the Type this query belongs to.\n    const type = schema.getType(model.singularName + (isFilter ? \"Filter\" : \"\"), true);\n\n    // Next we try to find the field from the type\n    schemaField = type\n      ? (isFilter ? type.inputFields! : type.fields!).find(f => f.name === name)\n      : undefined;\n\n    // Warn before we return null\n    if (!schemaField) {\n      Context.getInstance().logger.warn(\n        `Couldn't find the argument with name ${name} for the mutation/query ${\n          field ? field.name : \"(?)\"\n        }`\n      );\n    }\n\n    return schemaField;\n  }\n\n  /**\n   * Generates the fields for all related models.\n   *\n   * @param {Model} model\n   * @param {Array<Model>} path\n   * @returns {string}\n   */\n  static buildRelationsQuery(model: null | Model, path: Array<string> = []): string {\n    if (model === null) return \"\";\n\n    const context = Context.getInstance();\n    const relationQueries: Array<string> = [];\n\n    model.getRelations().forEach((field: Field, name: string) => {\n      let relatedModel: Model;\n\n      if (field.related) {\n        relatedModel = context.getModel(field.related.entity);\n      } else if (field.parent) {\n        relatedModel = context.getModel(field.parent.entity);\n      } else {\n        relatedModel = context.getModel(name);\n        context.logger.log(\n          \"WARNING: field has neither parent nor related property. Fallback to attribute name\",\n          field\n        );\n      }\n\n      // We will ignore the field, when it's already in the path. Means: When it's already queried. However there are\n      // cases where the model will have a relationship to itself. For example a nested category strucure where the\n      // category model has a parent: belongsTo(Category). So we also check if the model references itself. If this is\n      // the case, we allow the nesting up to 5 times.\n      const referencesItSelf = takeWhile(\n        path.slice(0).reverse(),\n        (p: string) => p === relatedModel.singularName\n      ).length;\n      const ignore = referencesItSelf\n        ? referencesItSelf > 5\n        : path.includes(relatedModel.singularName);\n\n      // console.log(`-----> Will ${ignore ? '' : 'not'} ignore ${model.singularName}.${name}, path: ${path.join('.')}`);\n\n      if (model.shouldEagerLoadRelation(name, field, relatedModel) && !ignore) {\n        const newPath = path.slice(0);\n        newPath.push(relatedModel.singularName);\n\n        relationQueries.push(\n          this.buildField(relatedModel, Model.isConnection(field), undefined, newPath, name, false)\n        );\n      }\n    });\n\n    return relationQueries.join(\"\\n\");\n  }\n}\n","import { Data, DispatchFunction } from '../support/interfaces';\nimport Context from '../common/context';\n\n/**\n * Provides some helper methods to interact with the Vuex-ORM store\n */\nexport class Store {\n  /**\n   * Inserts incoming data into the store. Existing data will be updated.\n   *\n   * @param {Data} data New data to insert/update\n   * @param {Function} dispatch Vuex Dispatch method for the model\n   * @return {Promise<Data>} Inserted data as hash\n   */\n  public static async insertData (data: Data, dispatch: DispatchFunction): Promise<Data> {\n    let insertedData: Data = {};\n\n    await Promise.all(Object.keys(data).map(async (key) => {\n      const value = data[key];\n      Context.getInstance().logger.log('Inserting records', value);\n      const newData = await dispatch('insertOrUpdate', { data: value });\n\n      Object.keys(newData).forEach((dataKey) => {\n        if (!insertedData[dataKey]) insertedData[dataKey] = [];\n        insertedData[dataKey] = insertedData[dataKey].concat(newData[dataKey]);\n      });\n    }));\n\n    return insertedData;\n  }\n}\n","import Model from \"../orm/model\";\nimport { upcaseFirstLetter } from \"../support/utils\";\n\n/**\n * Generic name generator for mutations and queries. In the future these methods may be influenced by the configuration.\n */\nexport default class NameGenerator {\n  public static getNameForPersist(model: Model) {\n    return this.getCRUDName(\"create\", model);\n  }\n\n  public static getNameForPush(model: Model) {\n    return this.getCRUDName(\"update\", model);\n  }\n\n  public static getNameForDestroy(model: Model) {\n    return this.getCRUDName(\"delete\", model);\n  }\n\n  public static getNameForFetch(model: Model, plural: boolean = false) {\n    return plural ? model.pluralName : model.singularName;\n  }\n\n  /**\n   * Internal helper to keep the code DRY. Just generates a name by leveraging the models singular name.\n   * @param {string} action Name of the action like 'create'\n   * @param {Model} model\n   * @returns {string} For example 'createBlogPost'\n   */\n  private static getCRUDName(action: string, model: Model) {\n    return `${action}${upcaseFirstLetter(model.singularName)}`;\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport { Arguments, Data, DispatchFunction } from \"../support/interfaces\";\nimport Model from \"../orm/model\";\nimport RootState from \"@vuex-orm/core/lib/modules/contracts/RootState\";\nimport Transformer from \"../graphql/transformer\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Schema from \"../graphql/schema\";\n\nconst inflection = require(\"inflection\");\n\n/**\n * Base class for all Vuex actions. Contains some utility and convenience methods.\n */\nexport default class Action {\n  /**\n   * Sends a mutation.\n   *\n   * @param {string} name Name of the mutation like 'createUser'\n   * @param {Data | undefined} variables Variables to send with the mutation\n   * @param {Function} dispatch Vuex Dispatch method for the model\n   * @param {Model} model The model this mutation affects.\n   * @param {boolean} multiple Tells if we're requesting a single record or multiple.\n   * @returns {Promise<any>}\n   */\n  protected static async mutation(\n    name: string,\n    variables: Data | undefined,\n    dispatch: DispatchFunction,\n    model: Model\n  ): Promise<any> {\n    if (variables) {\n      const context: Context = Context.getInstance();\n      const schema: Schema = await context.loadSchema();\n\n      const multiple: boolean = Schema.returnsConnection(schema.getMutation(name)!);\n      const query = QueryBuilder.buildQuery(\"mutation\", model, name, variables, multiple);\n\n      // Send GraphQL Mutation\n      let newData = await Context.getInstance().apollo.request(model, query, variables, true);\n\n      // When this was not a destroy action, we get new data, which we should insert in the store\n      if (name !== NameGenerator.getNameForDestroy(model)) {\n        newData = newData[Object.keys(newData)[0]];\n\n        // IDs as String cause terrible issues, so we convert them to integers.\n        newData.id = parseInt(newData.id, 10);\n\n        const insertedData: Data = await Store.insertData(\n          { [model.pluralName]: newData },\n          dispatch\n        );\n\n        // Try to find the record to return\n        const records = insertedData[model.pluralName];\n        const newRecord = records[records.length - 1];\n        if (newRecord) {\n          return newRecord;\n        } else {\n          Context.getInstance().logger.log(\n            \"Couldn't find the record of type '\",\n            model.pluralName,\n            \"' within\",\n            insertedData,\n            \". Falling back to find()\"\n          );\n          return model.baseModel.query().last();\n        }\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Convenience method to get the model from the state.\n   * @param {RootState} state Vuex state\n   * @returns {Model}\n   */\n  static getModelFromState(state: RootState): Model {\n    return Context.getInstance().getModel(state.$name);\n  }\n\n  /**\n   * Makes sure args is a hash.\n   *\n   * @param {Arguments|undefined} args\n   * @param {any} id When not undefined, it's added to the args\n   * @returns {Arguments}\n   */\n  static prepareArgs(args?: Arguments, id?: any): Arguments {\n    args = args || {};\n    if (id) args[\"id\"] = id;\n\n    return args;\n  }\n\n  /**\n   * Adds the record itself to the args and sends it through transformOutgoingData. Key is named by the singular name\n   * of the model.\n   *\n   * @param {Arguments} args\n   * @param {Model} model\n   * @param {Data} data\n   * @returns {Arguments}\n   */\n  static addRecordToArgs(args: Arguments, model: Model, data: Data): Arguments {\n    args[model.singularName] = Transformer.transformOutgoingData(model, data);\n    return args;\n  }\n\n  /**\n   * Transforms each field of the args which contains a model.\n   * @param {Arguments} args\n   * @returns {Arguments}\n   */\n  protected static transformArgs(args: Arguments): Arguments {\n    const context = Context.getInstance();\n\n    Object.keys(args).forEach((key: string) => {\n      const value: any = args[key];\n\n      if (value instanceof context.components.Model) {\n        const model = context.getModel(inflection.singularize(value.$self().entity));\n        const transformedValue = Transformer.transformOutgoingData(model, value);\n        context.logger.log(\n          \"A\",\n          key,\n          \"model was found within the variables and will be transformed from\",\n          value,\n          \"to\",\n          transformedValue\n        );\n        args[key] = transformedValue;\n      }\n    });\n\n    return args;\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Destroy action for sending a delete mutation. Will be used for record.$destroy().\n */\nexport default class Destroy extends Action {\n  /**\n   * @param {State} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} id ID of the record to delete\n   * @returns {Promise<any>} true\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { id, args }: ActionParams\n  ): Promise<boolean> {\n    if (id) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForDestroy(model);\n\n      const mockReturnValue = model.$mockHook(\"destroy\", { id });\n\n      if (mockReturnValue) {\n        await Store.insertData(mockReturnValue, dispatch!);\n        return true;\n      }\n\n      args = this.prepareArgs(args, id);\n\n      await Action.mutation(mutationName, args, dispatch!, model);\n      return true;\n    } else {\n      throw new Error(\"The destroy action requires the 'id' to be set\");\n    }\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport Transformer from \"../graphql/transformer\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\n\n/**\n * Fetch action for sending a query. Will be used for Model.fetch().\n */\nexport default class Fetch extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {ActionParams} params Optional params to send with the query\n   * @returns {Promise<Data>} The fetched records as hash\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    params?: ActionParams\n  ): Promise<Data> {\n    const context = Context.getInstance();\n    const model = this.getModelFromState(state!);\n\n    const mockReturnValue = model.$mockHook(\"fetch\", {\n      filter: params ? params!.filter || {} : {}\n    });\n\n    if (mockReturnValue) {\n      return Store.insertData(mockReturnValue, dispatch!);\n    }\n\n    await context.loadSchema();\n\n    // Filter\n    const filter =\n      params && params!.filter\n        ? Transformer.transformOutgoingData(model, params!.filter!, Object.keys(params!.filter!))\n        : {};\n\n    const bypassCache = params && params!.bypassCache;\n\n    // When the filter contains an id, we query in singular mode\n    const multiple: boolean = !filter[\"id\"];\n    const name: string = NameGenerator.getNameForFetch(model, multiple);\n    const query = QueryBuilder.buildQuery(\"query\", model, name, filter, multiple, multiple);\n\n    // Send the request to the GraphQL API\n    const data = await context.apollo.request(model, query, filter, false, bypassCache as boolean);\n\n    // Insert incoming data into the store\n    return Store.insertData(data, dispatch!);\n  }\n}\n","import { ActionParams, Arguments, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport Schema from \"../graphql/schema\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Mutate action for sending a custom mutation. Will be used for Model.mutate() and record.$mutate().\n */\nexport default class Mutate extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} name Name of the query\n   * @param {boolean} multiple Fetch one or multiple?\n   * @param {Arguments} args Arguments for the mutation. Must contain a 'mutation' field.\n   * @returns {Promise<Data>} The new record if any\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { args, name }: ActionParams\n  ): Promise<Data> {\n    if (name) {\n      const context: Context = Context.getInstance();\n      const model = this.getModelFromState(state!);\n\n      const mockReturnValue = model.$mockHook(\"mutate\", {\n        name,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      const schema: Schema = await context.loadSchema();\n      args = this.prepareArgs(args);\n\n      // There could be anything in the args, but we have to be sure that all records are gone through\n      // transformOutgoingData()\n      this.transformArgs(args);\n\n      // Send the mutation\n      return Action.mutation(name, args, dispatch!, model);\n    } else {\n      throw new Error(\"The mutate action requires the mutation name ('mutation') to be set\");\n    }\n  }\n}\n","import Context from \"../common/context\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Model from \"../orm/model\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Persist action for sending a create mutation. Will be used for record.$persist().\n */\nexport default class Persist extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} id ID of the record to persist\n   * @returns {Promise<Data>} The saved record\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { id, args }: ActionParams\n  ): Promise<Data> {\n    if (id) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForPersist(model);\n      const oldRecord = model.getRecordWithId(id);\n\n      const mockReturnValue = model.$mockHook(\"persist\", {\n        id,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        const newRecord = Store.insertData(mockReturnValue, dispatch!);\n        await this.deleteObsoleteRecord(model, newRecord, oldRecord);\n        return newRecord;\n      }\n\n      // Arguments\n      args = this.prepareArgs(args);\n      this.addRecordToArgs(args!, model, oldRecord);\n\n      // Send mutation\n      const newRecord = await Action.mutation(mutationName, args, dispatch!, model);\n\n      // Delete the old record if necessary\n      await this.deleteObsoleteRecord(model, newRecord, oldRecord);\n\n      return newRecord;\n    } else {\n      throw new Error(\"The persist action requires the 'id' to be set\");\n    }\n  }\n\n  /**\n   * It's very likely that the server generated different ID for this record.\n   * In this case Action.mutation has inserted a new record instead of updating the existing one.\n   *\n   * @param {Model} model\n   * @param {Data} record\n   * @returns {Promise<void>}\n   */\n  private static async deleteObsoleteRecord(model: Model, newRecord: Data, oldRecord: Data) {\n    if (newRecord && oldRecord && newRecord.id !== oldRecord.id) {\n      Context.getInstance().logger.log(\"Dropping deprecated record\", oldRecord);\n      return oldRecord.$delete();\n    }\n  }\n}\n","import { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Push action for sending a update mutation. Will be used for record.$push().\n */\nexport default class Push extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {Arguments} data New data to save\n   * @param {Arguments} args Additional arguments\n   * @returns {Promise<Data>} The updated record\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { data, args }: ActionParams\n  ): Promise<Data> {\n    if (data) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForPush(model);\n\n      const mockReturnValue = model.$mockHook(\"push\", {\n        data,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      // Arguments\n      args = this.prepareArgs(args, data.id);\n      this.addRecordToArgs(args, model, data);\n\n      // Send the mutation\n      return Action.mutation(mutationName, args, dispatch!, model);\n    } else {\n      throw new Error(\"The persist action requires the 'data' to be set\");\n    }\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport Transformer from \"../graphql/transformer\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Schema from \"../graphql/schema\";\n\n/**\n * Query action for sending a custom query. Will be used for Model.customQuery() and record.$customQuery.\n */\nexport default class Query extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} name Name of the query\n   * @param {boolean} multiple Fetch one or multiple?\n   * @param {object} filter Filter object (arguments)\n   * @param {boolean} bypassCache Whether to bypass the cache\n   * @returns {Promise<Data>} The fetched records as hash\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { name, filter, bypassCache }: ActionParams\n  ): Promise<Data> {\n    if (name) {\n      const context: Context = Context.getInstance();\n      const model = this.getModelFromState(state!);\n\n      const mockReturnValue = model.$mockHook(\"query\", {\n        name,\n        filter: filter || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      const schema: Schema = await context.loadSchema();\n\n      // Filter\n      filter = filter ? Transformer.transformOutgoingData(model, filter) : {};\n\n      // Multiple?\n      const multiple: boolean = Schema.returnsConnection(schema.getQuery(name)!);\n\n      // Build query\n      const query = QueryBuilder.buildQuery(\"query\", model, name, filter, multiple, false);\n\n      // Send the request to the GraphQL API\n      const data = await context.apollo.request(\n        model,\n        query,\n        filter,\n        false,\n        bypassCache as boolean\n      );\n\n      // Insert incoming data into the store\n      return Store.insertData(data, dispatch!);\n    } else {\n      throw new Error(\"The customQuery action requires the query name ('name') to be set\");\n    }\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport { parse } from \"graphql/language/parser\";\nimport { clone } from \"../support/utils\";\n\n/**\n * SimpleQuery action for sending a model unrelated simple query.\n */\nexport default class SimpleQuery extends Action {\n  /**\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} query The query to send\n   * @param {Arguments} variables\n   * @param {boolean} bypassCache Whether to bypass the cache\n   * @returns {Promise<any>} The result\n   */\n  public static async call(\n    { dispatch }: ActionParams,\n    { query, bypassCache, variables }: ActionParams\n  ): Promise<any> {\n    const context: Context = Context.getInstance();\n\n    if (query) {\n      const parsedQuery = parse(query);\n      const mockReturnValue = context.globalMockHook(\"simpleQuery\", {\n        name: parsedQuery.definitions[0][\"name\"].value,\n        variables\n      });\n\n      if (mockReturnValue) {\n        return mockReturnValue;\n      }\n\n      variables = this.prepareArgs(variables);\n\n      const result = await context.apollo.simpleQuery(query, variables, bypassCache);\n\n      // remove the symbols\n      return clone(result.data);\n    } else {\n      throw new Error(\"The simpleQuery action requires the 'query' to be set\");\n    }\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport { parse } from \"graphql/language/parser\";\nimport { clone } from \"../support/utils\";\n\n/**\n * SimpleMutation action for sending a model unrelated simple mutation.\n */\nexport default class SimpleMutation extends Action {\n  /**\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} query The query to send\n   * @param {Arguments} variables\n   * @returns {Promise<any>} The result\n   */\n  public static async call(\n    { dispatch }: ActionParams,\n    { query, variables }: ActionParams\n  ): Promise<any> {\n    const context: Context = Context.getInstance();\n\n    if (query) {\n      const parsedQuery = parse(query);\n      const mockReturnValue = context.globalMockHook(\"simpleMutation\", {\n        name: parsedQuery.definitions[0][\"name\"].value,\n        variables\n      });\n\n      if (mockReturnValue) {\n        return mockReturnValue;\n      }\n\n      variables = this.prepareArgs(variables);\n      const result = await context.apollo.simpleMutation(query, variables);\n\n      // remove the symbols\n      return clone(result.data);\n    } else {\n      throw new Error(\"The simpleMutation action requires the 'query' to be set\");\n    }\n  }\n}\n","import { PatchedModel, Options, ActionParams } from \"./support/interfaces\";\nimport Context from \"./common/context\";\nimport { Components } from \"@vuex-orm/core/lib/plugins/use\";\nimport { Destroy, Fetch, Mutate, Persist, Push } from \"./actions\";\nimport Query from \"./actions/query\";\nimport SimpleQuery from \"./actions/simple-query\";\nimport SimpleMutation from \"./actions/simple-mutation\";\nimport { isPlainObject } from \"./support/utils\";\n\n/**\n * Main class of the plugin. Setups the internal context, Vuex actions and model methods\n */\nexport default class VuexORMGraphQL {\n  /**\n   * @constructor\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   */\n  public constructor(components: Components, options: Options) {\n    Context.setup(components, options);\n    VuexORMGraphQL.setupActions();\n    VuexORMGraphQL.setupModelMethods();\n  }\n\n  /**\n   * Allow everything to read the context.\n   */\n  public getContext(): Context {\n    return Context.getInstance();\n  }\n\n  /**\n   * This method will setup following Vuex actions: fetch, persist, push, destroy, mutate\n   */\n  private static setupActions() {\n    const context = Context.getInstance();\n\n    context.components.RootActions.simpleQuery = SimpleQuery.call.bind(SimpleQuery);\n    context.components.RootActions.simpleMutation = SimpleMutation.call.bind(SimpleMutation);\n\n    context.components.Actions.fetch = Fetch.call.bind(Fetch);\n    context.components.Actions.persist = Persist.call.bind(Persist);\n    context.components.Actions.push = Push.call.bind(Push);\n    context.components.Actions.destroy = Destroy.call.bind(Destroy);\n    context.components.Actions.mutate = Mutate.call.bind(Mutate);\n    context.components.Actions.query = Query.call.bind(Query);\n  }\n\n  /**\n   * This method will setup following model methods: Model.fetch, Model.mutate, Model.customQuery, record.$mutate,\n   * record.$persist, record.$push, record.$destroy and record.$deleteAndDestroy, record.$customQuery\n   */\n  private static setupModelMethods() {\n    const context = Context.getInstance();\n\n    // Register static model convenience methods\n    (context.components.Model as typeof PatchedModel).fetch = async function(\n      filter: any,\n      bypassCache = false\n    ) {\n      let filterObj = filter;\n      if (!isPlainObject(filterObj)) filterObj = { id: filter };\n      return this.dispatch(\"fetch\", { filter: filterObj, bypassCache });\n    };\n\n    (context.components.Model as typeof PatchedModel).mutate = async function(\n      params: ActionParams\n    ) {\n      return this.dispatch(\"mutate\", params);\n    };\n\n    (context.components.Model as typeof PatchedModel).customQuery = async function({\n      name,\n      filter,\n      multiple,\n      bypassCache\n    }: ActionParams) {\n      return this.dispatch(\"query\", { name, filter, multiple, bypassCache });\n    };\n\n    // Register model convenience methods\n    const model = context.components.Model.prototype;\n\n    model.$mutate = async function({ name, args, multiple }: ActionParams) {\n      args = args || {};\n      if (!args[\"id\"]) args[\"id\"] = this.id;\n      return this.$dispatch(\"mutate\", { name, args, multiple });\n    };\n\n    model.$customQuery = async function({ name, filter, multiple, bypassCache }: ActionParams) {\n      filter = filter || {};\n      if (!filter[\"id\"]) filter[\"id\"] = this.id;\n      return this.$dispatch(\"query\", { name, filter, multiple, bypassCache });\n    };\n\n    model.$persist = async function(args: any) {\n      return this.$dispatch(\"persist\", { id: this.id, args });\n    };\n\n    model.$push = async function(args: any) {\n      return this.$dispatch(\"push\", { data: this, args });\n    };\n\n    model.$destroy = async function() {\n      return this.$dispatch(\"destroy\", { id: this.id });\n    };\n\n    model.$deleteAndDestroy = async function() {\n      await this.$delete();\n      return this.$destroy();\n    };\n  }\n}\n"],"names":["Object","defineProperty","exports","value","condition","message","Error","undefined","obj","_invariant2","_invariant","__esModule","default","Source","body","name","locationOffset","instance","Constructor","TypeError","_classCallCheck","this","line","column","source","position","lineRegexp","match","exec","index","length","highlightSourceAtLocation","location","lineOffset","columnOffset","getColumnOffset","contextLine","contextColumn","prevLineNum","toString","lineNum","nextLineNum","padLen","lines","split","whitespace","lpad","filter","Boolean","join","len","Array","str","error","printedLocations","nodes","forEach","node","loc","push","_location","getLocation","start","locations","concat","GraphQLError","positions","path","originalError","extensions","_nodes","isArray","_source","_positions","reduce","list","_locations","providedSource","map","pos","defineProperties","enumerable","writable","stack","configurable","captureStackTrace","prototype","create","constructor","_printError","printError","description","_GraphQLError","_extends","assign","target","i","arguments","key","hasOwnProperty","call","get","_syntaxError","syntaxError","_locatedError","locatedError","_formatError","formatError","leadingWhitespace","isBlank","rawString","commonIndent","indent","_i","slice","shift","pop","options","startOfFileToken","Tok","SOF","lastToken","token","lineStart","advance","advanceLexer","lookahead","kind","_blockStringValue2","_blockStringValue","EOF","next","readToken","COMMENT","BANG","DOLLAR","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","NAME","INT","FLOAT","STRING","BLOCK_STRING","charCodeAt","String","end","prev","printCharCode","code","isNaN","JSON","stringify","fromCharCode","toUpperCase","lexer","bodyLength","startPosition","positionAfterWhitespace","col","_error","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","a","b","c","d","char2hex","readString","unexpectedCharacterMessage","toJSON","inspect","QUERY","MUTATION","SUBSCRIPTION","FIELD","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","parseName","expect","_lexer","TokenKind","_kinds","parseDefinition","peek","parseExecutableDefinition","parseTypeSystemDefinition","peekDescription","unexpected","parseOperationDefinition","expectKeyword","experimentalFragmentVariables","parseFragmentName","variableDefinitions","parseVariableDefinitions","typeCondition","parseNamedType","directives","parseDirectives","selectionSet","parseSelectionSet","parseFragmentDefinition","OPERATION_DEFINITION","operation","parseOperationType","operationToken","many","parseVariableDefinition","VARIABLE_DEFINITION","variable","parseVariable","type","parseTypeReference","defaultValue","skip","parseValueLiteral","VARIABLE","SELECTION_SET","selections","parseSelection","parseFragment","nameOrAlias","alias","parseArguments","parseField","isConst","item","parseConstArgument","parseArgument","ARGUMENT","parseConstValue","parseValueValue","LIST","values","openKind","parseFn","closeKind","any","parseList","fields","parseObjectField","parseObject","parseStringLiteral","BOOLEAN","NULL","block","OBJECT_FIELD","parseDirective","DIRECTIVE","LIST_TYPE","NON_NULL_TYPE","NAMED_TYPE","keywordToken","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","parseSchemaDefinition","parseDescription","SCALAR_TYPE_DEFINITION","parseScalarTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","parseObjectTypeDefinition","INTERFACE_TYPE_DEFINITION","parseInterfaceTypeDefinition","types","parseMemberTypesDefinition","UNION_TYPE_DEFINITION","parseUnionTypeDefinition","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumTypeDefinition","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseInputObjectTypeDefinition","SCALAR_TYPE_EXTENSION","parseScalarTypeExtension","OBJECT_TYPE_EXTENSION","parseObjectTypeExtension","INTERFACE_TYPE_EXTENSION","parseInterfaceTypeExtension","UNION_TYPE_EXTENSION","parseUnionTypeExtension","ENUM_TYPE_EXTENSION","parseEnumTypeExtension","INPUT_OBJECT_TYPE_EXTENSION","parseInputObjectTypeExtension","parseTypeExtension","args","parseArgumentDefs","parseDirectiveLocation","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveDefinition","OPERATION_TYPE_DEFINITION","parseFieldDefinition","parseInputValueDef","INPUT_VALUE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","_directiveLocation","DirectiveLocation","startToken","noLocation","Loc","endToken","getTokenDesc","atToken","sourceObj","definitions","DOCUMENT","parseDocument","createLexer","root","visitor","visitorKeys","QueryDocumentKeys","inArray","keys","edits","parent","ancestors","newRoot","isLeaving","isEdited","clone","k","editOffset","ii","editKey","editValue","splice","result","isNode","visitFn","getVisitFn","BREAK","visitors","skipping","enter","fn","apply","leave","typeInfo","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","DirectiveDefinition","maybeNode","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor","ast","_visitor","visit","printDocASTReducer","op","varDefs","wrap","_ref","_ref2","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","isDescription","indexOf","replace","printBlockString","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_ref22","_ref23","_ref24","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","maybeArray","separator","x","array","maybeString","LARGE_ARRAY_SIZE","HASH_UNDEFINED","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","MAX_SAFE_INTEGER","argsTag","arrayTag","asyncTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","nullTag","objectTag","proxyTag","regexpTag","setTag","stringTag","symbolTag","undefinedTag","arrayBufferTag","dataViewTag","reIsHostCtor","reIsUint","typedArrayTags","freeGlobal","global","freeSelf","self","Function","freeExports","nodeType","freeModule","module","moduleExports","freeProcess","process","nodeUtil","binding","e","nodeIsTypedArray","isTypedArray","arraySome","predicate","mapToArray","size","setToArray","set","uid","func","transform","arrayProto","funcProto","objectProto","coreJsData","funcToString","maskSrcKey","IE_PROTO","nativeObjectToString","reIsNative","RegExp","Buffer","Symbol","Uint8Array","propertyIsEnumerable","symToStringTag","toStringTag","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","arg","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","clear","entry","ListCache","MapCache","SetCache","__data__","add","Stack","data","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","n","iteratee","baseTimes","isIndex","assocIndexOf","eq","baseGetTag","isOwn","tag","getRawTag","objectToString","baseIsArguments","isObjectLike","baseIsEqual","other","bitmask","customizer","object","equalFunc","objIsArr","othIsArr","objTag","getTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","byteLength","byteOffset","buffer","convert","isPartial","stacked","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","getAllKeys","objLength","othLength","skipCtor","objValue","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsNative","isObject","isFunction","test","baseKeys","Ctor","proto","arrLength","seen","arrValue","othIndex","has","keysFunc","symbolsFunc","offset","arrayPush","baseGetAllKeys","getSymbols","getMapData","getValue","hash","string","pairs","resIndex","arrayFilter","symbol","ArrayBuffer","resolve","ctorString","isLength","baseUnary","upcaseFirstLetter","input","charAt","downcaseFirstLetter","toLowerCase","prettify","query","print","parse","isPlainObject","getPrototypeOf","pick","props","prop","isEqual","lodashIsEqual","takeWhile","enabled","log","console","groupCollapsed","PREFIX","messages","groupEnd","warn","variables","fetchPolicy","prettified","group","trim","inflection","require","baseModel","singularName","singularize","entity","pluralName","pluralize","field","context","Context","getInstance","components","Number","Increment","Attr","BelongsTo","HasOne","MorphTo","MorphOne","model","originalFieldGenerator","bind","originalFields","boolean","Model","isFieldAttribute","_this","skipField","startsWith","skipFields","shouldSkipField","getRelations","relation","foreignKey","relations","found","models","MorphMany","MorphedByMany","MorphToMany","related","id","withAllRecursive","where","first","fieldName","relatedModel","eagerLoad","find","mock","$findMock","action","mocks","m","returnValue","r","$isPersisted","opts","cmp","f","cycles","aobj","bobj","isFinite","out","seenIndex","sort","isStringValue","isBooleanValue","isIntValue","isFloatValue","isVariable","isObjectValue","isListValue","isEnumValue","isNullValue","valueToObjectRepresentation","argObj","nestedArgObj_1","variableValue","listValue","nestedArgArrayObj","storeKeyNameFromField","directivesObj","directive","_a","getStoreKeyName","KNOWN_DIRECTIVES","filterKeys","queryArgs_1","filteredArgs_1","completeFieldName","stringifiedArgs","argumentsObjectFromField","argObj_1","resultKeyNameFromField","isField","selection","isInlineFragment","isIdValue","idObject","toIdValue","idConfig","generated","typename","isJsonValue","jsonObject","getDirectiveInfoFromField","directiveObj_1","shouldInclude","res","directiveArguments","directiveName","ifArgument","ifValue","evaledValue","flattenSelections","selectionNode","selected","getDirectiveNames","doc","definition","hasDirectives","names","some","getFragmentQueryDocument","document","fragmentName","actualFragmentName","fragments","sources","getMutationDefinition","checkDocument","mutationDef","operations","getOperationDefinition","getOperationDefinitionOrDie","def","getOperationName","getFragmentDefinitions","getQueryDefinition","queryDef","getMainDefinition","queryDoc","fragmentDefinition","createFragmentMap","symTable","fragment","getDefaultValues","defaultValues","defaultValueObj","factory","_typeof","iterator","fclone","refs","Date","subarray","isArrayLike","_l","_copy","copy","l","cloneDeep","TYPENAME_FIELD","isNotEmpty","getDirectiveMatcher","dir","addTypenameToSelectionSet","isRoot","lastIndexOf","removeDirectivesFromSelectionSet","agressiveRemove","remove","directiveMatcher","shouldKeep","removeDirectivesFromDocument","docClone","addTypenameToDocument","connectionRemoveConfig","willRemove","removeConnectionDirectiveFromDocument","getEnv","env","NODE_ENV","isEnv","isProduction","isTest","tryFunctionOrLogError","graphQLResultHasError","errors","getTime","NetworkStatus","haveWarned","warnOnceInDevelopment","msg","isNetworkRequestInFlight","networkStatus","_createClass","descriptor","protoProps","staticProps","hasSymbols","hasSymbol","getSymbol","getMethod","getSpecies","ctor","Observable","isObservable","hostReportError","setTimeout","enqueue","then","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","closeSubscription","_observer","_queue","_state","notifySubscription","observer","onNotify","queue","flushSubscription","observable","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscription","_subscriber","complete","reject","subscribe","done","_this2","_this3","_this4","C","hasSeed","hasValue","acc","_this5","_len","_key","startNext","v","from","_this6","subscriptions","outer","inner","completeIfDone","closed","s","method","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","err","return","_len2","items","_key2","configurabe","require$$0","zenObservable","validateOperation","OPERATION_FIELDS","link","_super","__extends","isTerminating","request","fromError","errorValue","transformOperation","transformedOperation","operationName","createOperation","starting","getKey","passthrough","forward","of","toLink","handler","ApolloLink","empty","links","y","left","right","leftLink","rightLink","second","firstLink","LinkError","nextLink","execute","symbolObservablePonyfill","ponyfill","window","$$observable","LinkObservable","isApolloError","FetchType","generateErrorMessage","graphQLErrors","graphQLError","errorMessage","networkError","extraInfo","__proto__","ApolloError","hasError","storeValue","policy","scheduler","_b","shouldSubscribe","onSubscribe","isCurrentlyPolling","isTornDown","queryId","queryManager","generateQueryId","observers","subscriptionHandles","ObservableQuery","that","obs","removeQuery","lastError","lastResult","loading","queryStoreValue","queryStore","errorPolicy","partial","queryLoading","ready","stale","__assign","isNetworkFetchPolicy","combinedOptions","fetchQuery","refetch","fetchMoreOptions","updateQuery","qid","normal","fetchMoreResult","previousResult","startGraphQLSubscription","subscriptionData","previous","onError","oldOptions","pollInterval","startPolling","stopPolling","tryFetch","setVariables","fetchResults","newVariables","mapFn","newResult","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","startPollingQuery","setUpQuery","tearDownQuery","addObservableQuery","startQuery","queryListenerForObserver","sub","removeObservableQuery","stopQuery","DedupLink","getContext","forceFetch","toKey","operationKey","inFlightRequestObservables","delete","subscribers","subscription_1","singleObserver_1","sharedObserver","ssrMode","QueryScheduler","fetchType","catch","listener","registeredQueries","addQueryListener","addQueryOnInterval","interval","intervalQueries","checkInFlight","queryOptions","pollingOptions","poll","clearInterval","pollingTimers","setInterval","fetchQueriesOnInterval","MutationStore","store","mutationId","mutationString","mutation","QueryStore","previousQuery","isSetVariables","previousVariables","storePreviousVariables","isPoll","isRefetch","metadata","fetchMoreForQueryId","fetchMore","markQueryResultClient","observableQueryIds","defaultQueryInfo","listeners","invalidated","newData","lastRequestId","observableQuery","queryDeduplication","_c","onBroadcast","_d","deduplicator","Deduplicator","QueryManager","optimisticResponse","updateQueriesByName","refetchQueries","awaitRefetchQueries","updateWithProxyFn","_e","cache","getCache","transformDocument","setQuery","generateUpdateQueriesInfo","ret","queryName","queryIdsByName","updater","mutationStore","initMutation","markMutationInit","updateQueries","update","storeResult","buildOperationForLink","markMutationResult","markMutationError","markMutationComplete","refetchQueryPromises","refetchQueries_1","refetchQuery","promise","refetchQueryByName","all","needToFetch","shouldFetch","requestId","generateRequestId","cancel","updateQueryWatch","invalidate","initQuery","networkResult","fetchRequest","markQueryError","removeFetchQueryPromise","previouslyHadError","getLastResult","getLastError","shouldNotifyIfLoading","networkStatusChanged","errorStatusChanged","notifyOnNetworkStatusChange","apolloError_1","info","isMissing","document_1","readResult","diff","optimistic","resultFromStore","queryDefinition","transformedOptions","returnPartialData","idCounter","addFetchQueryPromise","watchQuery","watch","callback","fetchQueryPromises","val","resetIds","queries","reset","clearStore","reFetchObservableQueries","includeStandby","observableQueryPromises","getObservableQueryPromises","isCacheEnabled","transformedDoc","markSubscriptionResult","stopQueryInStore","read","queryIdOrObservable","foundObserveableQuery","resetLastResults","errorsFromStore","markQueryResult","refetchedQueries","getQuery","newInfo","extraContext","transformForLink","getCacheKey","config","dataIdFromObject","initialCache","DataStore","ignoreErrors","writeWithErrors","write","dataId","optimistic_1","recordOptimisticTransaction","orig","cacheWrites_1","currentQueryResult","nextQueryResult","mutationResult","queryVariables","performTransaction","update_1","removeOptimistic","hasSuggestedDevtools","supportedDirectives","ssrForceFetchDelay","connectToDevTools","defaultOptions","disableNetworkFetches","mutate","resetStore","defaultConnectToDevTools","__APOLLO_CLIENT__","top","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","navigator","userAgent","debug","version","ApolloClient","initQueryManager","initProxy","readQuery","readFragment","writeQuery","writeFragment","writeData","cb","devToolsHookCb","payload","state","getStore","mutations","dataWithOptimisticResults","extract","resetStoreCallbacks","serializedState","restore","proxy","queryFromPojo","selectionSetFromObj","fragmentFromPojo","nestedSelSet","justTypenameQuery","ApolloCache","rootId","typenameResult","__typename","dataToWrite","HeuristicFragmentMatcher","idValue","ObjectCache","defaultNormalizedCacheFactory","seed","enhanceErrorWithDocument","enhancedError","WriteError","writeResultToStore","storeFactory","fragmentMatcherFunction","operationDefinition","fragmentMap","writeSelectionSetToStore","processedData","included","resultFieldKey","writeFieldToStore","substring","matches","fakeContext","hasMissingField","cacheRedirects","isGeneratedId","mergeWithGenerated","generatedKey","realKey","real","realValue","isDataProcessed","storeObject","storeFieldName","shouldMerge","processArrayValue","valueDataId","semanticId","escapedId","hadTypename","hasTypename","typenameChanged","json","newStoreObj","generatedId","itemDataId","graphql","resolver","rootValue","contextValue","variableValues","execOptions","mainDefinition","execContext","resultMapper","fragmentMatcher","executeSelectionSet","fieldResult","executeField","merge","fragmentResult","isLeaf","resultKey","executeSubSelectedArray","hasOwn","dest","src","srcVal","ID_KEY","readQueryFromStore","diffQueryAgainstStore","readStoreResolver","assertIdValue","objId","storeKeyName","fieldValue","storeObj","addPreviousResultToIdValues","graphqlAnywhere","idToPreviousResult_1","itemPreviousResult","resultFields","currentResultKeys_1","every","areNestedArrayItemsStrictlyEqual","RecordingCache","transaction","recordedData","record","startingState","defaultConfig","defaultDataIdFromObject","addTypename","_id","customResolvers","cacheResolvers","InMemoryCache","patches","opt","toObject","broadcastWatches","watches","toPerform","change","alreadySilenced","silenceBroadcast","patch","recordingCache","dataCache","typenameDocumentCache","defaultHttpOptions","includeQuery","includeExtensions","defaultHeaders","accept","content-type","fallbackHttpConfig","http","headers","throwServerError","response","statusCode","status","parseAndCheckHttpResponse","text","bodyText","parseError","checkFetcher","fetcher","fetch","library","createSignalIfSupported","AbortController","controller","signal","selectHttpOptionsAndBody","fallbackConfig","configs","credentials","serializeFetchParameter","p","label","serialized","selectURI","fallbackURI","contextURI","uri","createHttpLink","linkOptions","useGETForQueries","requestOptions","linkConfig","fetchOptions","chosenURI","contextConfig","_controller","newURI","setContext","abort","rewriteURIForGET","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","whitelist","$entitiy","includes","getModel","arrayModel_1","transformOutgoingData","$id","$self","recursiveCall","logger","transformIncomingData","localModel","connectionQueryMode","edges","newKey","isFieldNumber","parseFloat","endsWith","isTypeFieldOfPolymorphicRelation","parser","normalize","docCache","fragmentSourceMap","cacheKeyFromLoc","resetCaches","printFragmentWarnings","processFragments","astFragmentMap","sourceKey","disableFragmentWarnings","stripLoc","removeLocAtThisLevel","docType","valueType","cacheKey","parsed","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","gql","literals","httpLink","HttpLink","url","apolloClient","debugMode","bypassCache","logQuery","Apollo","getHeaders","Transformer","schema","t","getType","connection","typeName","Schema","getTypeNameOfField","allowNull","getRealType","ofType","introspectionQuery","database","Logger","apollo","collectModels","schemaWillBeLoaded","X-GraphQL-Introspection-Query","simpleQuery","__schema","processSchema","determineQueryMode","name_1","findGlobalMock","globalMocks","entities","augment","multiple","allowIdFields","getMutation","params","buildArguments","getQueryFields","buildRelationsQuery","header","__type","buildField","signature","isForeignKey","skipFieldDueId","schemaField","findSchemaFieldForArgument","isConnectionField","typeOrValue","QueryBuilder","determineAttributeType","isFilter","inputFields","relationQueries","referencesItSelf","reverse","ignore","shouldEagerLoadRelation","newPath","isConnection","dispatch","dataKey","insertedData","getCRUDName","plural","loadSchema","returnsConnection","buildQuery","NameGenerator","getNameForDestroy","parseInt","Store","insertData","records","newRecord","last","$name","transformedValue","getModelFromState","$mockHook","mockReturnValue","prepareArgs","Action","mutationName","getNameForFetch","transformArgs","getNameForPersist","getRecordWithId","deleteObsoleteRecord","newRecord_1","oldRecord","addRecordToArgs","$delete","getNameForPush","globalMockHook","parsedQuery","simpleMutation","setup","setupActions","setupModelMethods","RootActions","SimpleQuery","SimpleMutation","Actions","Fetch","persist","Persist","Push","destroy","Destroy","Mutate","Query","filterObj","customQuery","$mutate","$dispatch","$customQuery","$persist","$push","$destroy","$deleteAndDestroy"],"mappings":"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"}